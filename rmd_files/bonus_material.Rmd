# Bonus material

## Reshaping data

### Working with similarly named columns

There might be a situation where we have a lot of columns to gather, in which case it would be time consuming to type them all out individually. What happens if we want all of the week columns to be restructured?

In this case, we can use the `starts_with()` function to select all columns with a name that begins with 'wk':

```{r, purl=purl_example_code}
# Mapping all week columns to new variables called "weeks" and "rank"
billboard %>% tidyr::pivot_longer(cols = starts_with("wk"), names_to = "week", values_to = "rank") %>% head()
```


This has allowed us to convert a dataframe with 79 columns into one with only 5, while retaining all of the same information, which can be helpful for making further analysis easier.


### Working with similar columns 

In some circumstances pivoting can also be used to construct a more robust for ease of use in later stages of the analysis. In these cases the dataset contains variables that are similar in their structure with the aim being to gather them in to one, cleaner, format. Consider the `asncombe` dataset that comes with basic R as shown below:

```{r, purl=purl_example_code}
anscombe
```

As it is apparent, the basis for each variable is the same (x1,x2, y1,y2 etc) and so it would make sense to simply create pair `x` and `y` and depict their corresponding identifier `1,2,3,4` in a separate variable. 

In such cases, `pivot_longer` offers an elegant solution to the problem by automatically selecting the common patterns and using them as the new variables.

```{r, purl=purl_example_code}
# using ".value" and "everything()" to select common variables
anscombe %>% tidyr::pivot_longer(everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)" )
```


In the example above, the `.value` identifier enables selection of the common elements between `x1,x2,etc` and `y1,y2,etc` and then uses the findings as separate variables. 

The `everything()` argument, as the name would suggest, picks the entire variable set in the dataset.

Notice also the use of the `names_pattern = "(.)(.)"` option. This is a special kind of regex use where the values within the brackets are used to detect the kind of pattern to be used. 

The `names_pattern` or `name_sep()` options make explicit use of the `extract()` and  `separete()` tools respectively (discussed in more detail in the  next sections) utilizing regular expressions to detect the variable to pivot. In the former expression, the regex contained in the matching groups depicted within the brackets in the above expression, is what distinguishes one part of the variable from the other.  


## Separating and extracting column contents

An Important aspect of every data shaping mechanism is to be able to pick multiple columns or data entries within a variable  with a certain precision and without having to manually type them each time. 

The functions `separate()` and `extract()` were created for this purpose where regex is used to describe the pattern to pick and reshape.

Consider `table3` for example that comes with the `tidyr` package. One look at the table illustrates the problem that we are facing where the variable `rate` could be split into two different ones if somehow we could detect and pull out the values on either side of the separator.  


```{r, purl=purl_example_code}
table3
```

### Separate

The `separate()` function is build to help in cases where values in a column could be split based on a separator in place. On the above example in `table3` the following code splits the `rate` variable into `cases` and `population` accordingly 


```{r, purl=purl_example_code}
# separate() automatically detects the separator
table3 %>% tidyr::separate(rate, into = c("cases", "population"))
```

By default, the function will automatically detect any non-alphanumeric character and use that as a separator but its not limited to that. One can specify the separator manually using the `sep` option.

```{r, purl=purl_example_code}
# separate() manually  detects the separator
table3 %>% tidyr::separate(rate, into = c("cases", "population"), sep = "/")
```

At its heart, `separate()` uses regular expressions to detect and pull the corresponding characters. As a result the new columns are now of `char` type, something that can be changed by altering the state of the `convert` flag as shown below:


```{r, purl=purl_example_code}
# separate() manually detects the separator and convers the columns into the appropriate data type 
table3 %>% tidyr::separate(rate, into = c("cases", "population"), sep = "/", convert = TRUE)
```

### Extract

The `extract()` function lets you go a step further and allows you to define your own regex to be used for pattern patching. Using the same example as above, lets see how to split the `year` variable to `century` and `years`.

```{r, purl=purl_example_code}
table3 %>% tidyr::extract( col = year, into = c("century","years"), regex = "([0-9]{2})([0-9]{2})")
```

The `regex` option shown above uses the same syntax as described earlier in the chapter, in fact, it is possible to split the target variable into several others by expanding the bracket list as shown in the following block of code. The year variable is now split into three variables to depict the `century`, `decade` and `year`.


```{r, purl=purl_example_code}
table3 %>% tidyr::extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")
```

In addition, internally the pivot functions make explicit use of  `seaprate()` and `extract()` whenever a split or a regular expression is need to capture patterns present in name or within the content of a variable in the dataset. 


### Unite

Of course, extracting and creating new variables would not be complete without a function to revert back to the original target variable. In this case, the `unite()` function provides the means to do exactly that as shown in the example below.


```{r, purl=purl_example_code}
# the reshaped dataset
tab3 = table3 %>% tidyr::extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")

# going back to the original dataset - with separator
tab3 %>% tidyr::unite(new ,century, decade, year)
```

By default, the `_` separator is used after each component of the composite variable but as always, there are option in place to customize this behavior. In the following block of code the separator is removed giving the original variable before any alteration takes place.


```{r, purl=purl_example_code}
# going back to the original dataset - with no separators
tab3 %>% tidyr::unite(new ,century, decade, year, sep = "")
```



## Strings

### Escape characters and special charaters

Escape characters can be used to include other special characters inside a string as well. Since the escape character itself is a backslash, a double backslash (`\\`) is used to include a backslash character in a string. To see what the output would look like when used in text you can use the `writeLines()` function: 

```{r, purl=purl_example_code}
string5 <- "including \"double quotes\" in a string "
writeLines(string5)

string6 <- "including a backslash \\ in a string"
writeLines(string6)
```

Other special character pairs include newlines and tabs, denoted by `\n` and `\t` respectively, and you can enter `?"'"` or `?'"'` in the R console to see even more examples of where the escape character can be used. 

You can also add Unicode characters to strings. For example, the Greek letter mu can be included like this: 

```{r, purl=purl_example_code}
string7 <- "\u00b5" 
writeLines(string7)
```


### str_count()

A variation of `str_detect` is `str_count` and as the name suggests the function will count the instances of a pattern appearing in the target vector.

```{r}
x <- c("apple", "banana", "pear")
str_count(x, "a")
#> [1] 1 3 1

# On average, how many vowels per word?
mean(str_count(words, "[aeiou]"))
#> [1] 1.991837
```


## Regular Expressions

Matching patterns with regular expressions is usually covered in a very large topic and one that arguably should be covered on its own course, however here we will consider it as part of the general string manipulation section and will include a flavor of what can be achieved.  

### Normal Pattern Matching 

Simple pattern matching can be achieved by using the `str_view` function and specifying the `string` and `pattern` arguments as shown below:

```{r, results=F}

x <- c("apple", "banana", "pear")
str_view(x, "an")

```

The complexity of the match can be adjusted and wildcards can be used as well in the form of `.` as in 

```{r, results=F}
str_view(x, ".a.")

```

An important thing to remember here is that you are looking for given pattern in a string or a vector of strings. Specifying the pattern to look for can be sometimes tricky and therefore is recommended to take a look at the accompanied information sheet for the `stringr` package located [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf). 

The most common functions for regular expressions as well as ways to structure your pattern can be found in the above link.

### Escaping characters

We saw previously that the wildcard is represented by `.`, what happens if your pattern needs to include the dot `.`?

For cases such as these there is a need to "escape" a character using the backlash `\`. So for example the dot (`.`) as stated previously would be normally used as `\.` in a regular expression. However, a problem arises since strings are used to represent regular expressions, they also use the backlash to represent an escaped character. The solution is to use the double backlash as in `\\.` to signify that we want to "escape" the dot (`.`) in a regular expression pattern.


```{r, results=F}

# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)


# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")

```


If there is a need to match the `\` character itself then you will need to use the double version `\\` for regular expressions and since this is a string you will need to add one more `\` followed by the actual character. So four backlash characters will need to be used!


```{r}
#to see this in a string
x <- "a\\b"
writeLines(x)

# to view the result in a RegEx
str_view(x, "\\\\")

```


throughout this section the pattern for a RegEx will be presented as `\.` whereas the actual string as `\\.`. 



#### Exercises


1. Explain why each of these strings don’t match a \: "\", "\\", "\\\".

2. How would you match the sequence "'\?

3. What patterns will the regular expression \..\..\.. match? How would you represent it as a string?



### Anchors


It is sometimes useful to match a pattern starting from the beginning or the end of a string. In these cases an anchor is used to notify the engine that we are using a point of origin. 

More specifically, the start of the string is denoted by `^` and the end by `$`

```{r, results=F}

x <- c("apple", "banana", "pear")
str_view(x, "^a")

str_view(x, "a$")


```


You can also use both in one pattern and this is useful when the entire string is to be matched 

```{r, results=F}
# this will output all possible matches
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

# notice the difference in the result here
str_view(x, "^apple$")


```

#### Exercises

1. How would you match the literal string "$^$"?

2. Given the corpus of common words in stringr::words, create regular expressions that find all words that:

      +Start with “y”.
      +End with “x”
      +Are exactly three letters long. (Don’t cheat by using str_length()!)
      +Have seven letters or more.
Hint: Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words.


### Character Classes

Similar to the wildcard you saw previously, there are other reserved patterns that serve a similar purpose for example:
 
 + `\d`: matches any digit.
 + `\s`: matches any whitespace (e.g. space, tab, newline).
 + `[abc]`: matches a, b, or c.
 + `[^abc]`: matches anything except a, b, or c.

A reminder here that if you want to use the above to pattern then you will need to escape them as we learned earlier. So the `\d` string would be used as `\\d` in a pattern.

In addition, there is an alternative to the backlash way of escaping a character that involves creating a class for a single character as in `[.]` for example. In many cases this is considered more intuitive that using the backlash.

A character class containing a single character is a nice alternative to backslash escapes when you want to include a single meta-character in a regex. Many people find this more readable.

```{r, results= F }
# Look for a literal character that normally has special meaning in a regex
str_view(c("abc", "a.c", "a*c", "a c"), "a[.]c")

str_view(c("abc", "a.c", "a*c", "a c"), ".[*]c")

str_view(c("abc", "a.c", "a*c", "a c"), "a[ ]")
```

However, some characters will have a certain meaning even inside brackets and so the backslash for escaping them is still necessary, these are `] \ ^ -`.

Alternation is used to pick between patterns, for example `abc|d..f` will pick a pattern with either `c` or `d` in the definition. Note how the `|` is used, it will only pick between the immediate characters and not between the entire patterns on either side. If it gets to a point where it becomes confusing remember to use parenthesis to clear things up. 

```{r, results = F}
str_view(c("grey", "gray"), "gr(e|a)y")
```

#### Exercises

1. Create regular expressions to find all words that:
    +Start with a vowel.
    +That only contain consonants. (Hint: thinking about matching “not”-vowels.)
    +End with` ed`, but not with `eed`.
    +End with `ing` or` ise`.
2. Empirically verify the rule “i before e except after c”.
3. Is “q” always followed by a “u”?
4. Write a regular expression that matches a word if it’s probably written in British English, not American English.
5. Create a regular expression that will match telephone numbers as commonly written in your country.


### Repetition

It is sometimes necessary for a certain pattern to appear multiple time within a string, in such cases these repetitions can be coded with regular expressions to automate the search process. 

for example:

+ `?`: 0 or 1
+ `+`: 1 or more
+ `*`: 0 or more

```{r}

x <- "1888 is the longest year in Roman numerals: MDCCCLXXXVIII"
str_view(x, "CC?")

str_view(x, "CC+")

str_view(x, 'C[LX]+')

```

Another key aspect of the above code is that the number or precedence here dictates that the character just before the operator will be affected. This means that parenthesis will need to be used as in `bana(na)+` to capture more than one character.

It is also possible to specify the number of repetitions explicitly by using:

+ `{n}`: exactly n
+ `{n,}`: n or more
+ `{,m}`: at most m
+ `{n,m}`: between n and m

```{r}

str_view(x, "C{2}")


str_view(x, "C{2,}")

str_view(x, "C{2,3}")

```


To also note here that the system will match as many of the characters that it can find. To switch this behavior off and use what is called "lazy" matching (instead of "greedy" as specified earlier) the `?` operator can be used as follows:

```{r}
str_view(x, 'C{2,3}?')

str_view(x, 'C[LX]+?')
```

#### Exercises


1. Describe the equivalents of `?`, `+`,` *` in `{m,n}` form.

2. Describe in words what these regular expressions match: (read carefully to see if I’m using a regular expression or a string that defines a regular expression.)

      + `^.*$`
      + `"\\{.+\\}"`
      + `\d{4}-\d{2}-\d{2}`
      + `"\\\\{4}"`
3. Create regular expressions to find all words that:

      + Start with three consonants.
      + Have three or more vowels in a row.
      + Have two or more vowel-consonant pairs in a row.
      
4. Solve the beginner regexp crosswords at [https://regexcrossword.com/challenges/beginner].



