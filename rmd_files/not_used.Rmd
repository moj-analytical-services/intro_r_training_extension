# Iteration


## Introduction

This chapter introduces how to use loops to repeatedly execute a piece of code.

A general rule of thumb in programming is to avoid copying and pasting a piece of code more than once; if you find that you are repeating similar pieces of code over and over again, this is a sign that either a loop or a [function](https://github.com/moj-analytical-services/writing_functions_in_r) (or both) are required. Keeping your code concise will help make it more readable and easier to understand.


## For loops

Let's start with a very basic example to illustrate what a for loop does. Say we wanted to print the numbers 1 to 5; without a for loop we'd need to write something like this:

```{r, collapse = TRUE, purl=purl_example_code}
print(1)
print(2)
print(3)
print(4)
print(5)
```

Clearly there is some code repetition here, so we can achieve the same result using a for loop:

```{r, purl=purl_example_code}
for (i in 1:5) {
  print(i)
}
```

Inside the brackets of the for loop you define a variable (in this case called `i`), along with what you want to iterate over (referred to as the iterable - in this case the numbers 1 to 5, denoted `1:5` in R). For each iteration, the variable `i` will take on a value equal to the next element of the iterable. The loop body goes inside the curly brackets, which is where you define what you want to happen for each iteration (in this case printing the value of `i`).

In the previous example we iterated over a sequence of numbers, but in R you can iterate over anything you like. Here's a similar example, but iterating over a vector of strings instead of a sequence of numbers:

```{r, purl=purl_example_code}
strings <- c("spam", "egg", "chips", "beans")

for (string in strings) {
  print(string)
}
```

If you wanted to get an index number for each element of the iterable, you can use the `seq_along()` function. For example:

```{r, purl=purl_example_code}
strings <- c("spam", "egg", "chips", "beans")

for (i in seq_along(strings)) {
  # Use paste() to combine two strings together
  print(paste(i, strings[i]))
}
```

You can also use for loops to populate or modify a vector or dataframe. The following example shows how we can add the first ten numbers of the Fibonacci sequence to a vector:

```{r, purl=purl_example_code}
n <- 10 # Specify what length we want our output vector to be
fibo <- vector("numeric", n) # Define an empty numeric vector of length n that we'll populate using the loop

# Set up the first couple of numbers to get the sequence started
fibo[1] <- 0 
fibo[2] <- 1

# Add the rest of the sequence
for (i in 3:n) {
  fibo[i] <- fibo[i-1] + fibo[i-2]
}

print(fibo)
```

When writing a for loop you must define something to iterate over a fixed number of times in advance. It is also possible to iterate indefinitely using a different kind of loop - this is covered in the section on while loops, below.


### Exercise

Write a for loop to print "The current date is ..." for each date in the following string vector:

```{r, purl=purl_example_code}
dates <- c("2020-03-01", "2020-06-01", "2020-09-01", "2020-12-01")
```

**Hint:** You can use the `paste()` function to join strings together.

---
```{r, include=show_solution, purl=purl_solutions}
# Solution
for (date in dates) {
  print(paste("The current date is", date))
}
```
---


### Handling outputs of unknown length

There are cases where the size of an output from a loop is not known beforehand. For example, this might be because different iterations result in outputs of different lengths.

Let's say we want to join together dataframes of different lengths. There is a shared folder prepared in the alpha-r-training s3 bucket, which contains some data for us to read in and combine together. First we need to get a list of file paths to read from:

```{r, message=F, warning=F, purl=purl_example_code}
# Get a vector of file paths to iterate over
files <- s3tools::list_files_in_buckets("alpha-r-training", prefix="intro-r-extension", path_only=T)
files <- files[grepl(".csv", files)] # This makes sure that only csv files are included

files
```

Now we can use a for loop to read in each file as a dataframe, and add each dataframe to a list. After the for loop, the `bind_rows()` function from dplyr can be used to combine the data into a single dataframe. This is more memory efficient than appending the dataframes in each loop iteration.

```{r, message=F, warning=F, purl=purl_example_code}
# First define an empty list with the same length as the number of datasets to be read in
fruit_list <- vector("list", length(files))

# Loop over each file, and add the data to a list
for (i in seq_along(files)) {
  fruit_list[[i]] <- s3tools::s3_path_to_full_df(files[i])
}

# Combine the list of dataframes into a single dataframe
fruit <- dplyr::bind_rows(fruit_list)
fruit
```

### Conditionally exiting a for loop

You might want to stop a for loop iterating under a certain condition. In this case you can use a `break` statement in combination with an 'if' or 'if...else' statement, like so:

```{r, purl=purl_example_code}

for (i in 1:10) {
  # Exit the for loop if i is greater than 5
  if (i > 5){
    break
  }
  
  print(i)
}
```

### Conditionally skip to the next iteration

The `next` statement can be use to skip to the next iteration of the loop under a certain condition. For example, we can skip to the next iteration if the iterable is equal to 3:

```{r, purl=purl_example_code}

for (i in 1:5) {
  # Skip this iteration if i equals 3
  if (i == 3){
    next
  }
  
  print(i)
}
```


## While loops

There may be cases where we want to keep looping over a piece of code until a certain condition is met, rather than having to specify in advance how many times a loop should run. In these cases a while loop can be used.

For example, we can use a while loop to achieve a similar result to the first for loop example above:

```{r, purl=purl_example_code}
# First specify an initial value for the variable used in the while loop
i <- 1

# Now define a while loop
while (i <= 5) { # The loop will continue until the condition i<=5 is met
  print(i)
  i = i + 1 # Set the value of the variable for the next loop iteration
}
```

The syntax for a while loop is similar to that of a for loop, but in the brackets a condition is specified instead of an iterable. Prior to writing the while loop you'll also need to specify a start value for the variable used in the loop, and there should be something in the body of the loop to change the variable during each iteration - otherwise the condition can never be met!

Generally a while loop should only be used in circumstances where it isn't possible to achieve the desired result using a for loop. The reason for this is that it's quite easy to accidentally set up an infinite loop, where a bug in the code means that the condition is never met for a while loop to end.







# Reshaping data


The tidyr package can help us to reshape dataframes - this can be really helpful when we need to transform between tables that are easier to read and tables that are easier to analyse. For example, we might need to structure a dataset so that it can be manipulated more easily at a later stage of the analysis.

These situations may arise when there is more than one category associated with each value in a dataset. The dataset can be **lengthened** or **widened** (increasing the number of rows or columns, respectively), and this process is commonly referred to as **pivoting**.


## Transforming from wide to long format

Let's take a look at the `billboard` dataset supplied with tidyr (it should be available when you load the package), which contains the rank of songs in the year 2000. The dataset has 79 columns (one for each week, starting from Oct 1999, along with the artist, track name, and release date) and 317 rows.

```{r, purl=purl_example_code}
# Preview the data
billboard %>% head(10)
```

We can use the `pivot_longer()` function to help restructure this dataframe by decreasing the number of columns while increasing the number of rows. For example, we can map the first four week columns into a pair of new variables, called `month1` and `rank`.


```{r, purl=purl_example_code}
# Start by mapping a single month 
billboard_longer <- billboard %>%
  tidyr::pivot_longer(cols = c(wk1,wk2, wk3, wk4), names_to = "week_of_month1", values_to = "rank") %>% head()

# Display what we've done
billboard_longer %>% dplyr::select(artist, track, date.entered, week_of_month1, rank)
```

In the `pivot_longer()` function, we've specified variables/columns to be **gathered** into a new pair of columns using the `cols()` argument, then the `names_to` argument specifies the name of a new column to contain the names of the gathered columns, and `values_to` specifies the name of a new column to contain the corresponding values.  



## Transforming from long to wide format

The `pivot_wider()` function is the inverse of `pivot_longer()`, and transforms a dataframe to a **wider** format, with more columns and fewer rows. This wider format is often preferrable for displaying data, as it easier for a person to look at and interpret.

Consider the `fish_encounters` dataset, which contains a record of fish that are detected by various monitoring stations.

```{r, purl=purl_example_code}
fish_encounters %>% head(10)
```

We can use the `pivot_wider()` function to restructure this dataframe into a wide format: 

```{r, purl=purl_example_code}
fish_encounters %>% tidyr::pivot_wider(names_from = station, values_from = seen)
```

The `names_from` argument is used to specify the column containing categories we want to split across multiple columns, and the `values_from` argument contains the corresponding values for each category. 

In this dataframe there are some combinations of `fish` and `station` that don't exist in the original data, therefore the `values_fill` argument can be used to specify a value for these. In this case we've chosen to fill the NA values with zero:

```{r, purl=purl_example_code}
fish_encounters %>% tidyr::pivot_wider(names_from = station, values_from = seen, values_fill = list(seen = 0))
```


### Aggregating with `pivot_wider`

Consider the `warpbreaks` dataset, which describes the results of a designed experiment with nine replicates for every combination of wool (A and B) and tension (L, M, H). 

```{r, purl=purl_example_code}
warpbreaks %>% dplyr::select(wool, tension, breaks)
```

Note the warning that appears when trying to widen this dataset. This is because some combinations of `wool` and `tension` are repeated several times. 

```{r, purl=purl_example_code}
warpbreaks %>% tidyr::pivot_wider(names_from = wool, values_from = breaks)
```

To deal with this issue, we can use the optional `values_fn` argument in the `pivot_wider()` function, which allows us to specify a function to use to aggregate the multiple values. For example, we can specify to calculate the mean number of breaks for each combination of `wool` and `tension` like so:

```{r, purl=purl_example_code}
warpbreaks %>%
  tidyr::pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = list(breaks = mean)
  )
```


## Exercises 

#### Exercise 1 

Why does the following code fail?

```{r, purl=purl_example_code}
#the table to use
table4a
```

```{r, purl=purl_example_code, eval=F}
table4a %>% tidyr::pivot_longer(1999, 2000, names_to = "year", values_to = "value")
```


#### Exercise 2

Consider the following dataset and apply `pivot_wider()` to **spread** the values in `name`, do you agree with the results after pivoting? 

Hint. Could a new column solve the problem, what other solution could we apply?

```{r, purl=purl_example_code}
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)
```


#### Exercise 3

Consider the followign simple tibble, what kind of pivoting would you use, `pivot_longer()` or `pivot_wider()` ?

```{r, purl=purl_example_code}
rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)
```


```{r, include=show_solution, purl=purl_solutions}
# Exercise 1 solution
table4a %>% tidyr::pivot_longer(cols = !country, names_to = "year",values_to = "value")
```


```{r, include=show_solution, purl=purl_solutions}
# Exercise 2 solution

# Without changing anything on the dataset
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)
people %>% tidyr::pivot_wider(names_from = name, values_from = value)

# Solution 1 - adding a new column
people = tribble(~name, ~key, ~value, ~dkey,
                 "Phil Woods", "age",45,1,
                 "Phil Woods", "height",185,1,
                 "Phil Woods", "age",50,0,
                 "Jess Cordero", "age",45,1,
                 "Jess Cordero", "height",156,1)

people %>% tidyr::pivot_wider(names_from = name, values_from = value)

# Solution 2  - uniqueness
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 # "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)

people %>% tidyr::pivot_wider(names_from = name, values_from = value)
```



```{r, include=show_solution, purl=purl_solutions}
# Exercise 3 solution

rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)

#use of pivot_longer
rcj %>% tidyr::pivot_longer(cols = c(male, female), names_to = "gender", values_to = "count")

# use of  pivot_wider 
rcj %>% tidyr::pivot_wider(names_from = judge, values_from = c(male, female))
```








### Introduction

In this chapter we look at strings and how to work with them. The `stringr` package from `tidyverse` contains a great number of functions to help manipulate strings. 

There are two ways to create a string in R, by using either single or double quotes. There is no practical difference in behaviour for the two options, but the convention is to use double quotes (`"`). 

There is an advantage to having two ways to define a string, which is that the two quotation marks can be combined for cases when the string itself needs to contain a quotation mark. Here are some examples of how to define a string in R: 

```{r, purl=purl_example_code}
string1 <- "a string using double quotes"
string2 <- 'another string using single quotes'

string1
string2

# Some strings containing quotation marks
string3 <- "here is a 'quote' within a string"
string4 <- 'here is a "quote" within a string'

string3
string4
```

Notice the difference in `string4` - R has added escape characters (`\`) before the double quote marks. These escape characters change the behaviour of the following character. In this case it stops the following double quote mark from defining the end of the string, and instead allows it to be a part of the string.

Often it is necessary to work with a set of strings in a character vector, and in the following sections we'll look at how various `stringr` functions can help us work with character vectors. A new character vector can be constructed using the `c()` function:

```{r, purl=purl_example_code}
string_vector <- c("a", "vector", "of", "strings")
```

### String length

The first `stringr` function we'll look at is `str_length()`, which returns the length of each string in a character vector:

```{r, purl=purl_example_code}
# Find out how many characters are in each string
stringr::str_length(string_vector)
```

### Combining strings

The `str_c()` function is used to combine multiple strings together, like so:

```{r, purl=purl_example_code}
stringr::str_c("some", "strings", "to", "combine")
```

There are two optional arguments, `sep` and `collapse` that can be used to modify the behaviour of `str_c()`. The `sep` argument allows us to define a separator to put between the strings when they're combined:

```{r, purl=purl_example_code}
# Using custom separator
stringr::str_c("some", "space", "separated", "strings", sep = " ")
```

The `str_c()` is especially useful because it is vectorised, and when applying it to character vectors the `collapse` argument can be used to combine a vector of strings into a single string:

```{r, purl=purl_example_code}
# Collasping a character vector
vector_to_collapse <- c("some", "strings", "to", "combine")
stringr::str_c(vector_to_collapse, collapse="")
```
The value of `collapse` will determine how the collapsed strings are separated.

You can input multiple string vectors to `str_c()`, and it will combine them together:

```{r, purl=purl_example_code}
string_vector1 <- c("A", "B", "C", "D")
string_vector2 <- c("1", "2", "3", "4")
stringr::str_c(string_vector1, string_vector2, sep=" - ")
```

```{r, purl=purl_example_code}
string_vector1 <- c("A", "B", "C", "D")
string_vector2 <- c("1", "2", "3", "4")
stringr::str_c(string_vector1, string_vector2, sep=" - ", collapse=" ")
```

It can also combine a single string with a vector of strings, like so: 

```{r, purl=purl_example_code}
# The single string will be 'recycled' to match the length of the vector
stringr::str_c("a", c("b", "c", "d"), sep = " ")

# Compare with what happens when we combine these strings with c() 
c("a", c("b", "c", "d"))
```

### Subsetting strings

Selecting part of a string can be done using the `str_sub()` function. The `start` and `end` arguments are used to define the part of the string you want to extract.

```{r, purl=purl_example_code}
x <- c("First value", "Second value", "Third value")
stringr::str_sub(x, start=1, end=3)

# Negative values for the start and end count backwards from the end of the string
stringr::str_sub(x, start=-5, end=-1)
```
Note that the `str_sub()` will still work if the end point is beyond the length of the string.


### Detecting a matched pattern

The `str_detect()` function can be used to check if part of a string matches a particular pattern. For example, let's say we wanted to check if any strings in a string vector contain "blue":   

```{r, purl=purl_example_code}
colours <- c("scarlet red", "ultramarine blue", "cadmium red", "cobalt blue", "cerulean blue")
stringr::str_detect(colours, "blue")
```

Because booleans (`TRUE` or `FALSE`) can be represented as numbers (1 or 0), you can apply numeric functions to boolean vectors:

```{r, purl=purl_example_code}
# Count how many strings contain 'blue'
sum(stringr::str_detect(colours, "blue"))
```

#### Regular expressions

Regular expressions (regex) are extremely helpful for pattern matching. Since regex could be an entire course by itself, here we only introduce a few basics to get started. See the [further reading](#further-reading) section if you're interested in learning more.

* `[:alpha:]` or `[A-Za-z]`: All uppercase and lowercase letters
* `[:digit:]` or `[0-9]`: All numbers
* `[:space:]` or `\\s`: A single space
* `^a`: Begins with 'a'
* `a$`: Ends with 'a'
* `[^a]`: Anything other than 'a'

We can use regex to help extract a more general pattern, such as only strings that contain letters:
```{r, purl=purl_example_code}
colours <- c("1.", "ultramarine blue", "2. cadmium red", "cobalt blue", "-")
stringr::str_detect(colours, "[:alpha:]")
```
Or only strings that contain letters and numbers:
```{r, purl=purl_example_code}
stringr::str_detect(colours, "[:alnum:]")
```
Or only strings that contain something other than letters, numbers, and spaces:
```{r, purl=purl_example_code}
stringr::str_detect(colours, "[^[:alnum:][:space:]]")
```


### Extracting a matched pattern

We can use the `str_extract()` function to extract strings that match a particular pattern:

```{r, purl=purl_example_code}
colours <- c("scarlet red", "ultramarine blue", "cadmium red", "cobalt blue", "cerulean blue")
stringr::str_extract(colours, "blue")
```


### Replacing a matched pattern

You can use the `str_replace()` and `str_replace_all()` functions to find and replace parts of a string. `str_replace()` replaces the first instance of the pattern, whereas `str_replace_all()` replaces all instances of the pattern:

```{r, purl=purl_example_code}
colours <- c("scarlet...red", "ultramarine.blue", "cadmium_red", "cobalt blue", "cerulean-blue")

# Replace the first character that isn't a letter or number with an underscore
stringr::str_replace(colours, "[^[:alnum:]]", "_")
# Replace all characters that aren't a letter or number with an underscore
stringr::str_replace_all(colours, "[^[:alnum:]]", "_")
```


### Exercise

Remove all spaces from the following string:

```{r, purl=purl_example_code}
string <- "The quick brown fox jumps over the lazy dog."
```

**Hint:** You can remove a matched pattern by replacing it with an empty string (`""`).

---

```{r, include=show_solution, purl=purl_solutions}
# Solution
string <- stringr::str_replace_all(string, " ", "")
string
```

---

