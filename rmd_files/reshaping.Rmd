# Reshaping data


```{r, echo=F, message=F, results=F}

# loading packages
# 
library(tidyr)
library(dplyr)
library(readr)



```

The tidyr package can help us to reshape dataframes - this can be really helpful when we need to transform between tables that are easier to read and tables that are easier to analyse. The aim here is to structure the resulting datasets so that they could be manipulated easier in further stages of the processing. 

#################################

to mention the resourses: 

the link below 

https://tidyr.tidyverse.org/dev/articles/pivot.html#generate-column-name-from-multiple-variables-1

and also the book R for data science.

#################################


Let's look at an example using the `offenders` data set as presented in the previous sectrions. In many scenarios, although the data could be complete in the sense of it containing the desired variables, it is not quite in the right format requiering additional manipulation to bring it in line.

This is usualy the case when the variables needed are originaly created as subcategories within a current variable. The process to extract them results to  **lengthening** or **widening** the origianl dataset and this is commonly reffered to as **pivoting**. It should also be mentioned at this point that pivoting was created to replace the existing `gather()` and `spread()` functions. This is not to say that the old versions cannot be used anymore, its just that they will no longer receive any updates from the developer given their more advance counterparts.

As a general articaft of the this process, the resulting data set has either an increased number of rows or collumns respectrively. Interpretation largely depens on the project at hand where the current stage of the sytem determines the optimal structure of the data to be supplied.  


## Lengthening the dataset

Consider the `billboard` dataset supplied with tidyr (should be in you workspace when you load the package) containing  the rank of songs for the year 2000. Inspecting the dataset shows that there are in total 79 columns, one for each week (starting from Oct 1999) and also including a few additional identifiers.

The aim now is to create a single variable to house the different weeks in order to create a different representation of for the data. First we start by the mapping the first motnh into a single variable.

```{r}
?billboard

# notice the dimensions of the data
dim(billboard)


#to see the structure of the data
billboard %>% arrange(desc(date.entered)) %>% tail()



#starting by mapping a single month 
billboard %>% pivot_longer(cols = c(wk1,wk2, wk3, wk4), names_to = "month1", values_to = "rank") 

# and to see clearly the contents of the new variable
billboard %>% pivot_longer(cols = c(wk1,wk2, wk3, wk4), names_to = "month1", values_to = "rank") %>% .$month1 %>% head()

```


The way the `pivot_longer` function works is, you specify the columns to be **gathered** followed by defining the resultant new variables to store their names and corresponding values.  

### Working with multiple columns

As it is evident, the problem now is that we have too many columns to pass them individually. What happens if we want all of the weeks to be transfered as subcategories to a new variable called *weeks*?

In that case, the following structure comes into play where regular expressions are used to pick all the varaibles to be mapped.



```{r}



#mapping all weeks to one varable called "weeks" 
billboard %>% pivot_longer(cols = starts_with("wk"), names_to = "weeks", values_to = "rank") %>% head()


```


And so with this neat little trick, we've managed to bring the dataset into a better looking structure making further manipulation easier. Of courser, this is not all we can do with the data, there is a wide range of tools at our disposal to allow us not only to pick the varaibles we need but also to split the contents of them into new columns, with more on that in the following sections. 


### Working with similar columns 

In some circumstances pivoting can also be used to construct a more robust for ease of use in later stages of the analysis. In these cases the dateset contains variables that are similat in their structure with the aim being to gather them in to one, cleaner, format. Consider the `asncombe` dataset that comes with basic R as shown below:

```{r}
#dataset
anscombe

```

As it is apprent, the basis for each varible is the same (x1,x2, y1,y2 etc) and so it would make sense to simply create pair `x` and `y` and depict their corresponding identifier `1,2,3,4` in a separate variable. 

In such cases, `pivot_longer` offers an elegant solution to the problem by automatically selecting the common patterns and using them as the new variables.

```{r}

# using ".value" and "everything()" to select common variables
anscombe %>% pivot_longer(everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)" )


```


In the example above, the `.value` identifier enables selection of the common elements between `x1,x2,etc` and `y1,y2,etc` and then uses the findings as separate variables. 

The `everything()` argument, as the neme would suggest, picks the entire variable set in the dataset.

Notice also the use of the `names_pattern = "(.)(.)"` option. This is a special kind of regex use where the values within the brackets are used to detect the kind of pattern to be used. 

The `names_pattern` or `name_sep()` options make explicit use of the `extract()` and  `separete()` tools respectively (discussed in more detail in the  next sections) utilising regular expressions to detect the varaible to pivot. In the former expression, the regex contained in the matching groups depicted within the brackets in the above expression, is what distinguishes one part of the variable from the other.  


## Widening the dataset

`pivot_wider()` is the opposite `pivot_longer()` tranforming a dataset to a **wider** format. It is not used as often but  has still some value in presenting a dataset in a different light should the situation calls for it.

Consider the `fish_encounters` dataset, contributed by Myfanwy Johnston depicted below. It describes whether fish swimming down a river are detected or not by automatic monitoring stations.

```{r}

fish_encounters
#> # A tibble: 114 x 3
#>    fish  station  seen
#>    <fct> <fct>   <int>
#>  1 4842  Release     1
#>  2 4842  I80_1       1
#>  3 4842  Lisbon      1
#>  4 4842  Rstr        1
#>  5 4842  Base_TD     1
#>  6 4842  BCE         1
#>  7 4842  BCW         1
#>  8 4842  BCE2        1
#>  9 4842  BCW2        1
#> 10 4842  MAE         1
#> # … with 104 more rows
```

A simple use of the function can provide a better understanding of what the data contains and also make it more useful for potential use in later stages of a processing system where specific input from each station can be utilised. 


```{r}
fish_encounters %>% pivot_wider(names_from = station, values_from = seen)
#> # A tibble: 19 x 12
#>    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
#>    <fct>   <int> <int>  <int> <int>   <int> <int> <int> <int> <int> <int> <int>
#>  1 4842        1     1      1     1       1     1     1     1     1     1     1
#>  2 4843        1     1      1     1       1     1     1     1     1     1     1
#>  3 4844        1     1      1     1       1     1     1     1     1     1     1
#>  4 4845        1     1      1     1       1    NA    NA    NA    NA    NA    NA
#>  5 4847        1     1      1    NA      NA    NA    NA    NA    NA    NA    NA
#>  6 4848        1     1      1     1      NA    NA    NA    NA    NA    NA    NA
#>  7 4849        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#>  8 4850        1     1     NA     1       1     1     1    NA    NA    NA    NA
#>  9 4851        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#> 10 4854        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#> # … with 9 more rows

```

The general use is very similar to that presented in ``pivot_longer()` with `names_from` targeting the column containing the subcategories to plit from and `values_from` the correposning values associated with each category. 

Notice that there will be cases where there is no match and these will initially be filled with `NA`. Simply setting the option `values_fill` to a value of your choise will replaced teh `NA` values to something more meaningful.   


```{r}
fish_encounters %>% pivot_wider(
  names_from = station,
  values_from = seen,
  values_fill = 0
)
#> # A tibble: 19 x 12
#>    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
#>    <fct>   <int> <int>  <int> <int>   <int> <int> <int> <int> <int> <int> <int>
#>  1 4842        1     1      1     1       1     1     1     1     1     1     1
#>  2 4843        1     1      1     1       1     1     1     1     1     1     1
#>  3 4844        1     1      1     1       1     1     1     1     1     1     1
#>  4 4845        1     1      1     1       1     0     0     0     0     0     0
#>  5 4847        1     1      1     0       0     0     0     0     0     0     0
#>  6 4848        1     1      1     1       0     0     0     0     0     0     0
#>  7 4849        1     1      0     0       0     0     0     0     0     0     0
#>  8 4850        1     1      0     1       1     1     1     0     0     0     0
#>  9 4851        1     1      0     0       0     0     0     0     0     0     0
#> 10 4854        1     1      0     0       0     0     0     0     0     0     0
#> # … with 9 more rows
```


## separating and extracting column contents


## Exercises 



```{r}







anscombe %>%
 pivot_longer(everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)"
 )

# extract
df <- data.frame(x = c(NA, "a-b", "a-d", "b-c", "d-e"))
df %>% extract(x, "A")
df %>% extract(x, c("A", "B"), "([[:alnum:]]+)-([[:alnum:]]+)")

# If no match, NA:
df %>% extract(x, c("A", "B"), "([a-d]+)-([a-d]+)")

df %>% extract(x, c("A", "B"), "(.)-([d])")


#separate
#


df <- data.frame(x = c(NA, "a.b", "a.d", "b.c"))
df %>% separate(x, c("A", "B"), sep = "\\.", remove = F)



# with the offenders data set

offenders %>% extract(SENTENCE,c("A","B"), regex = "(.+)_(.+)")

offenders %>% separate(SENTENCE, c("A","B"), sep = "_")





a = anscombe %>%
  pivot_longer(everything(),
    names_to = c(".value", "set"),
    names_pattern = "(.)(.)"
  ) %>%
  arrange(set)

```

In the `names_from` argument of `pivot_wider()`, we've specifed that we want to create new columns based on the different categories in the `SENTENCE` column - so there will be one new column for each of the three categories that appear in `SENTENCE`. Then we use the `values_from` argument to specify that we want values from the `offender_count` column to go into those new columns.


## Transforming from wide to long format

In order to reverse the reshaping that we've just done, and go back from a wide format to a long format, we can use the `pivot_longer()` function:

```{r}
# offenders_summary <- offenders_summary %>%
#   tidyr::pivot_longer(cols = -REGION, names_to = "SENTENCE", values_to = "offender_count")
# 
# offenders_summary
```

The `cols` argument of `pivot_longer()` has been set to `-REGION`, which means that all columns apart from `REGION` will be reshaped. Then the `names_to` argument is used to specify that we want the names of those columns to go into a new column called `SENTENCE`, and the `values_to` argument is used to specify that we want the values in those column to go into a new column called `offender_count`.

### Exercise


adding exercise for the pivoting functions - these are new function for the most recent versions of the tidy r package

(Placeholder)

