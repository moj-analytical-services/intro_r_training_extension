# Reshaping data


```{r, echo=F, message=F, results=F}

# loading packages
# 
library(tidyr)
library(dplyr)
library(readr)



```

The tidyr package can help us to reshape dataframes - this can be really helpful when we need to transform between tables that are easier to read and tables that are easier to analyse. For example, we might need to structure a dataset so that it can be manipulated more easily at a later stage of the analysis.

These situations may arise when there is more than one category associated with each value in a dataset. The dataset can be **lengthened** or **widened** (increasing the number of rows or columns, respectively), and this process is commonly referred to as **pivoting**.


## Transforming from wide to long format

Let's take a look at the `billboard` dataset supplied with tidyr (it should be available when you load the package), which contains the rank of songs in the year 2000. The dataset has 79 columns (one for each week, starting from Oct 1999, along with the artist, track name, and release date) and 317 rows.

```{r}
billboard %>% head(10)
```

The aim now is to create a single variable to house the different weeks in order to create a different representation of the data. First we start by the mapping the first month into a single variable.



```{r}
# Start by mapping a single month 
billboard_longer <- billboard %>%
  tidyr::pivot_longer(cols = c(wk1,wk2, wk3, wk4), names_to = "month1", values_to = "rank") %>% head()

# Display what we've done
billboard_longer %>% select(artist, track, date.entered, month1, rank)

```


The way the `pivot_longer` function works is, you specify the columns to be **gathered** followed by defining the resultant new variables to store their names and corresponding values.  

### Working with multiple columns

As it is evident, the problem now is that we have too many columns to pass them individually. What happens if we want all of the weeks to be transferred as subcategories to a new variable called *weeks*?

In that case, the following structure comes into play where regular expressions are used to pick all the variables to be mapped.



```{r}



#mapping all weeks to one varable called "weeks" 
billboard %>% pivot_longer(cols = starts_with("wk"), names_to = "weeks", values_to = "rank") %>% head()


```


And so with this neat little trick, we've managed to bring the dataset into a better looking structure making further manipulation easier. Of courser, this is not all we can do with the data, there is a wide range of tools at our disposal to allow us not only to pick the variables we need but also to split the contents of them into new columns, with more on that in the following sections. 


### Working with similar columns 

In some circumstances pivoting can also be used to construct a more robust for ease of use in later stages of the analysis. In these cases the dataset contains variables that are similar in their structure with the aim being to gather them in to one, cleaner, format. Consider the `asncombe` dataset that comes with basic R as shown below:

```{r}
#dataset
anscombe

```

As it is apparent, the basis for each variable is the same (x1,x2, y1,y2 etc) and so it would make sense to simply create pair `x` and `y` and depict their corresponding identifier `1,2,3,4` in a separate variable. 

In such cases, `pivot_longer` offers an elegant solution to the problem by automatically selecting the common patterns and using them as the new variables.

```{r}

# using ".value" and "everything()" to select common variables
anscombe %>% pivot_longer(everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)" )


```


In the example above, the `.value` identifier enables selection of the common elements between `x1,x2,etc` and `y1,y2,etc` and then uses the findings as separate variables. 

The `everything()` argument, as the name would suggest, picks the entire variable set in the dataset.

Notice also the use of the `names_pattern = "(.)(.)"` option. This is a special kind of regex use where the values within the brackets are used to detect the kind of pattern to be used. 

The `names_pattern` or `name_sep()` options make explicit use of the `extract()` and  `separete()` tools respectively (discussed in more detail in the  next sections) utilizing regular expressions to detect the variable to pivot. In the former expression, the regex contained in the matching groups depicted within the brackets in the above expression, is what distinguishes one part of the variable from the other.  


## Transforming from long to wide format

`pivot_wider()` is the opposite `pivot_longer()` transforming a dataset to a **wider** format. It is not used as often but  has still some value in presenting a dataset in a different light should the situation calls for it.

Consider the `fish_encounters` dataset, contributed by **Myfanwy Johnston** depicted below. It describes whether fish swimming down a river are detected or not by automatic monitoring stations.

```{r}

fish_encounters
#> # A tibble: 114 x 3
#>    fish  station  seen
#>    <fct> <fct>   <int>
#>  1 4842  Release     1
#>  2 4842  I80_1       1
#>  3 4842  Lisbon      1
#>  4 4842  Rstr        1
#>  5 4842  Base_TD     1
#>  6 4842  BCE         1
#>  7 4842  BCW         1
#>  8 4842  BCE2        1
#>  9 4842  BCW2        1
#> 10 4842  MAE         1
#> # … with 104 more rows
```

A simple use of the function can provide a better understanding of what the data contains and also make it more useful for potential use in later stages of a processing system where specific input from each station can be utilized. 


```{r}
fish_encounters %>% pivot_wider(names_from = station, values_from = seen)
#> # A tibble: 19 x 12
#>    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
#>    <fct>   <int> <int>  <int> <int>   <int> <int> <int> <int> <int> <int> <int>
#>  1 4842        1     1      1     1       1     1     1     1     1     1     1
#>  2 4843        1     1      1     1       1     1     1     1     1     1     1
#>  3 4844        1     1      1     1       1     1     1     1     1     1     1
#>  4 4845        1     1      1     1       1    NA    NA    NA    NA    NA    NA
#>  5 4847        1     1      1    NA      NA    NA    NA    NA    NA    NA    NA
#>  6 4848        1     1      1     1      NA    NA    NA    NA    NA    NA    NA
#>  7 4849        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#>  8 4850        1     1     NA     1       1     1     1    NA    NA    NA    NA
#>  9 4851        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#> 10 4854        1     1     NA    NA      NA    NA    NA    NA    NA    NA    NA
#> # … with 9 more rows

```

The general use is very similar to that presented in ``pivot_longer()` with `names_from` targeting the column containing the subcategories to split from and `values_from` the corresponding values associated with each category. 

Notice that there will be cases where there is no match and these will initially be filled with `NA`. Simply setting the option `values_fill` to a value of your choice will replaced the `NA` values to something more meaningful.   


```{r}
fish_encounters %>% pivot_wider(names_from = station, values_from = seen,
  values_fill = list(seen = 0))
#> # A tibble: 19 x 12
#>    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW
#>    <fct>   <int> <int>  <int> <int>   <int> <int> <int> <int> <int> <int> <int>
#>  1 4842        1     1      1     1       1     1     1     1     1     1     1
#>  2 4843        1     1      1     1       1     1     1     1     1     1     1
#>  3 4844        1     1      1     1       1     1     1     1     1     1     1
#>  4 4845        1     1      1     1       1     0     0     0     0     0     0
#>  5 4847        1     1      1     0       0     0     0     0     0     0     0
#>  6 4848        1     1      1     1       0     0     0     0     0     0     0
#>  7 4849        1     1      0     0       0     0     0     0     0     0     0
#>  8 4850        1     1      0     1       1     1     1     0     0     0     0
#>  9 4851        1     1      0     0       0     0     0     0     0     0     0
#> 10 4854        1     1      0     0       0     0     0     0     0     0     0
#> # … with 9 more rows
```


### Aggregating with with `pivot_wider`

Consider the  `warpbreaks` dataset that comes with basic R, it describes the results of a designed experiment with nine replicates for every combination of wool (A and B) and tension (L, M, H). 


```{r}

#converting into a tibble and rearranging the vars
warpbreaks %>% as_tibble() %>% select(wool,tension, breaks)

# the code above aims attempts to instil clarity in the output

```


Notice the problem that appears when trying to widen this dataset. Uniqueness is not maintained since this is a repeated experiment with the same value of breaks for each tension value. 

```{r}
warpdata = warpbreaks %>% pivot_wider(names_from = wool, values_from = breaks)
#> Warning: Values are not uniquely identified; output will contain list-cols.
#> * Use `values_fn = list` to suppress this warning.
#> * Use `values_fn = length` to identify where the duplicates arise
#> * Use `values_fn = {summary_fun}` to summarise duplicates
#> # A tibble: 3 x 3
#>   tension A         B        
#>   <fct>   <list>    <list>   
#> 1 L       <dbl [9]> <dbl [9]>
#> 2 M       <dbl [9]> <dbl [9]>
#> 3 H       <dbl [9]> <dbl [9]>
```

The default output here is a list containing all the associated **break** values. One other, and perhaps more informative, approach would be to include a statistic  to describe the contents in that list. 

For that purpose, `pivot _wider()` offers the `values_fn` option where a suitable function is defined to describe the list with t single value. 

```{r}
warpbreaks %>%
  pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = list(breaks = mean)
  )
#> # A tibble: 3 x 3
#>   tension     A     B
#>   <fct>   <dbl> <dbl>
#> 1 L        44.6  28.2
#> 2 M        24    28.8
#> 3 H        24.6  18.8
```


## Separating and extracting column contents

An Important aspect of every data shaping mechanism is to be able to pick multiple columns or data entries within a variable  with a certain precision and without having to manually type them each time. 

The functions `separate()` and `extract()` were created for this purpose where regex is used to describe the pattern to pick and reshape.

Consider `table3` for example that comes with the `tidyr` package. One look at the table illustrates the problem that we are facing where the variable `rate` could be split into two different ones if somehow we could detect and pull out the values on either side of the separator.  


```{r}
table3


```

### Separate

The `separate()` function is build to help in cases where values in a column could be split based on a separator in place. On the above example in `table3` the following code splits the `rate` variable into `cases` and `population` accordingly 


```{r}
# separate() automatically detects the separator
table3 %>% separate(rate, into = c("cases", "population"))

```

By default, the function will automatically detect any non-alphanumeric character and use that as a separator but its not limited to that. One can specify the separator manually using the `sep` option.

```{r}
# separate() manually  detects the separator
table3 %>% separate(rate, into = c("cases", "population"), sep = "/")


```

At its heart, `separate()` uses regular expressions to detect and pull the corresponding characters. As a result the new columns are now of `char` type, something that can be changed by altering the state of the `convert` flag as shown below:


```{r}

# separate() manually detects the separator and convers the columns into the appropriate data type 
table3 %>% separate(rate, into = c("cases", "population"), sep = "/", convert = TRUE)


```

### Extract

The `extract()` function lets you go a step further and allows you to define your own regex to be used for pattern patching. Using the same example as above, lets see how to split the `year` variable to `century` and `years`.

```{r}

#
table3 %>% extract( col = year, into = c("century","years"), regex = "([0-9]{2})([0-9]{2})")


```

The `regex` option shown above uses the same syntax as described earlier in the chapter, in fact, it is possible to split the target variable into several others by expanding the bracket list as shown in the following block of code. The year variable is now split into three variables to depict the `century`, `decade` and `year`.


```{r}

table3 %>% extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")

```

In addition, internally the pivot functions make explicit use of  `seaprate()` and `extract()` whenever a split or a regular expression is need to capture patterns present in name or within the content of a variable in the dataset. 


### Unite

Of course, extracting and creating new variables would not be complete without a function to revert back to the original target variable. In this case, the `unite()` function provides the means to do exactly that as shown in the example below.


```{r}
#the reshaped dataset
tab3 = table3 %>% extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")

#going back to the original dataset - with separator
tab3 %>% unite(new ,century, decade, year)

```

By default, the `_` separator is used after each component of the composite variable but as always, there are option in place to customize this behavior. In the following block of code the separator is removed giving the original variable before any alteration takes place.


```{r}
#going back to the original dataset - with no separators
tab3 %>% unite(new ,century, decade, year, sep = "")
```


Additional material material for this chapter can be found in [here](https://tidyr.tidyverse.org/dev/articles/pivot.html#generate-column-name-from-multiple-variables-1), as well as in the book by the same author, Hadley Wickam, titled [R For Data Science](https://r4ds.had.co.nz/).


## Exercises 

### Pivoting

#### Exercise 1 

Why does the following code fail?

```{r, , eval= F}
#the table to use
table4a


table4a %>% pivot_longer(1999,2000, names_to = "year",values_to = "value")


```


#### Exercise 2

Consider the following dataset and apply `pivot_wider()` to **spread** the values in `name`,  do you agree with the results after pivoting? 


Hint. Could a new column solve the problem, what other solution could we apply?


```{r, eval=FALSE}
people = tribble(~name, ~key, ~value,
                 #------------/------/-----,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)


```




#### Exercise 3

Consider the followign simple tibble, what kind of pivoting would you use, `pivot_longer()` or `pivot_wider()` ?


```{r}

rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)



```



### Separating and Extracting

#### Exercise 1

What to the additional arguments `extra` and `fill` do in `separate()`?  

Experiment with the various option in using the following datasets.


```{r}

tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))

```


#### Exercise 2


Both  `unite()` and `separate()` have a remove option. What does in to and how can it be utilized

#### Exercise 3

Compare `separate()` and `extract()`, why are there so many option to separate but only one `unite()`?

## Solutions

### Pivoting

#### Exercise 1

```{r, eval= F}

table4a %>% pivot_longer(cols = !country, names_to = "year",values_to = "value")


```



#### Exercise 2


```{r, eval=FALSE}

#withough changing anything on the dataset
people = tribble(~name, ~key, ~value,
                 #------------/------/-----,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)
people %>% pivot_wider(names_from = name, values_from = value)



# solution 1 - adding a new column
people = tribble(~name, ~key, ~value, ~dkey,
                 #------------/------/-----,
                 "Phil Woods", "age",45,1,
                 "Phil Woods", "height",185,1,
                 "Phil Woods", "age",50,0,
                 "Jess Cordero", "age",45,1,
                 "Jess Cordero", "height",156,1)

people %>% pivot_wider(names_from = name, values_from = value)



#solution 2  - uniqueness
people = tribble(~name, ~key, ~value,
                 #------------/------/-----,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 # "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)


people %>% pivot_wider(names_from = name, values_from = value)



```



### Exercise 3


```{r, eval=FALSE}
rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)

#alternative table to try with no NAs
# rcj = tribble( ~judge, ~male, ~female,
#                     "yes", 4, 10, 
#                     "no", 20, 12)


#use of pivot_longer
rcj %>% pivot_longer(cols = c(male, female),   names_to = "gender", values_to = "count")


# use of  pivot_wider 
rcj %>% pivot_wider(names_from = judge, values_from = c(male, female))



```




### Separating and Extracting

#### Exercise 1

typing `?separate()` shows all the options and their meaning. Try experimenting with them to discover more of what they do.

```{r, eval=FALSE}

tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  separate(x, c("one", "two", "three"))



```


#### Exercise 2



Solution: typing `?separate()` in the command line shows all the  information needed here. The `remove` option is there to remove the input columns from the output. 
=======

#### Exercise 3



Solution: one suggestion is that there is only one way to unite the multiple strings but a number of different ways to split them apart. 





