
# Reshaping data


## Introduction

The exact same data can be represented in different orientations, depending on the purpose.

A dataframe that is in long format has a single column for each variable. The number of columns is minimised, at the expense of having many rows.

A dataframe that is in wide format spreads a variable across several columns. The number of rows is minimised, at the expense of many columns.

There are advantages and disadvantages of each depending on context, and it is useful to know how to switch between these. It is very easy with the `tidyverse` functions (package `tidyr`) `pivot_wider()` and `pivot_longer()`.


## Widening data

We read in a data table.

```{r, purl=purl_example_code}
# read in the fake annual offences data
annual_offences <- 
  Rs3tools::s3_path_to_full_df(
    s3_path = "s3://alpha-r-training/intro-r-extension/annual_offences_fake.csv", 
    colClasses = c("integer", "character", "integer")) %>%
  tibble::tibble()

head(annual_offences)
```

---

```{r, purl=purl_example_code}
n_rows <- dim(annual_offences)[1]
n_cols <- dim(annual_offences)[2]
print(paste("The table is", n_rows, "rows by", n_cols, "cols, making", n_rows * n_cols, "cells", sep = " "))
```

The data represent fake frequencies of offences from 2016 to 2020, represented by real offence codes. If an offence was prosecuted in a year, there is a corresponding line in this data table, with the offence code indicated by the `offence_code` column, the year indicated by the `year` column, and the `count` column representing the number of times the offence was prosecuted. If an offence was not prosecuted in a year, the corresponding combination of `year` and `offence` does not exist. The table has been sorted by year and offence code.

---

The long format may be a good way to store data like these for some purposes, but what if we want to put it into wide format, e.g. to make it easier for a human to read? We use the `tidyr` function `pivot_wider()`:

```{r, purl=purl_example_code}
# basic implementation of pivot_wider()
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count'
  )

head(wide_annual_offences)
```

---

```{r, purl=purl_example_code}
n_rows <- dim(wide_annual_offences)[1]
n_cols <- dim(wide_annual_offences)[2]
print(paste("The table is", n_rows, "rows by", n_cols, "cols, making", n_rows * n_cols, "cells", sep = " "))
```

What's happened? We passed `count` to the argument `values_from` and `year` to the argument `names_from`. This tells the function that we want to make new columns based on `year`, and populate it with the values from `count`.

Remember that the data are sorted first by year, and then by offence? If we imagine each year as a stack of data, what we're effectively doing here is taking the count data for each stack and putting them in their own column.

---

There are a couple of ways we could get more useful results from this function, though.

First, it's generally not a good idea to have column names that begin with numbers. Fortunately, `pivot_wider()` has the useful argument `names_prefix` to remedy this:

```{r, purl=purl_example_code}
# adding a prefix to new columns
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_'
  )
head(wide_annual_offences)
```

---

When transforming count data like this we may have legitimate good reason to replace our NAs with 0s, which we can do with `values_fill()`:

```{r, purl=purl_example_code}
# filling in NAs with 0
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_',
    values_fill = 0
  )
head(wide_annual_offences)
```

---

Once our table is in wide format, and clean, we can easily do transformations like this. Here we use `dplyr` functions to create a new column that adds up yearly totals across each column that has count data:

```{r, purl=purl_example_code}
#starting by mapping a single month 
wide_annual_offences_with_totals <- wide_annual_offences %>%
  dplyr::mutate(
    count_2016_2020 =
      rowSums(dplyr::across(dplyr::starts_with("count")))
  )
head(wide_annual_offences_with_totals)
```

---

The final and most advanced thing we will do with `pivot_wider()` is to pass it an auxiliary function to transform the values that it places in its new columns.

Here we are passing an anonymous function which itself calls the `round()` function to round our counts. Setting the `digits` argument of `round()` to -1 means that the values get rounded to the nearest 10, rather than the default behaviour of rounding to the nearest whole number.

```{r, purl=purl_example_code}
#mapping all weeks to one variable called "weeks" 
wide_annual_offences_rounded <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_',
    values_fill = 0,
    values_fn = ~ round(.x, digits = -1)
  )
head(wide_annual_offences_rounded)
```


## Lengthening data

Let's consider our earlier widened table, with original counts, columns with prefixes and NAs replaced with 0s.

What if we want to go from our widened table back to our original one, here?

```{r, purl=purl_example_code}
head(wide_annual_offences, 3)
head(annual_offences, 3)
```

---

We use the function `pivot_longer()` for this. You can pass column names to it like this:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = c('count_2016', 'count_2017', 'count_2018', 'count_2019', 'count_2020')
  )
head(long_annual_offences)
```

---

Or, as our column names are conveniently named with a prefix, we can use `starts_with()` from `dplyr` again:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count')
  )
head(long_annual_offences)
```

---

Essentially, these data are the same as what we started with, but there are some differences we need to iron out in order to get back where we started.

```{r, purl=purl_example_code}
head(annual_offences, 3)
head(long_annual_offences, 3)
```

```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

---

There are several differences, which we can correct via arguments to `pivot_wider()` and some `dplyr` functions.

First, the default column name `value` has been assigned to our count, which we correct with the argument `values_to`, giving it the label we see in the original table:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count'
  )
head(long_annual_offences)
```

```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

---

There's another default name that it's assigned too --- it's used `name` when we want `year` to indicate the years. We correct this with an equivalent argument:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year'
  )
head(long_annual_offences)
```

```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

---

We also want to remove those prefixes:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  )
head(long_annual_offences)
```

```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

---

Still more to do! We have more rows in our new table, and that's because of those year/offence combinations where there are no incidences.

```{r, purl=purl_example_code}
n_rows <- dim(annual_offences)[1]
n_cols <- dim(annual_offences)[2]
print(paste("The original table is", n_rows, "rows by", n_cols, "cols, making", n_rows * n_cols, "cells", sep = " "))

n_rows <- dim(long_annual_offences)[1]
n_cols <- dim(long_annual_offences)[2]
print(paste("Our working table is", n_rows, "rows by", n_cols, "cols, making", n_rows * n_cols, "cells", sep = " "))

```

---

Let's get `dplyr` involved, and filter these out:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  ) %>%
  dplyr::filter(count > 0)
```

We now have the same number of rows in original table and the one we're working on:
```{r, purl=purl_example_code}
nrow(long_annual_offences) == nrow(annual_offences)
```

---

But we're still not quite there...
```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

Finally, we use `dplyr` to: 1) fix data types and reorder columns with `transmute()`, 2) order rows with `arrange()`:

```{r, purl=purl_example_code}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  ) %>%
  dplyr::filter(count > 0) %>%
  dplyr::transmute(
    year = as.integer(year),
    offence_code,
    count
  ) %>%
  dplyr::arrange(year, offence_code)
```

---

What do they both look like now?

```{r, purl=purl_example_code}
head(annual_offences, 3)
head(long_annual_offences, 3)
```

---

Success!

```{r, purl=purl_example_code}
identical(long_annual_offences, annual_offences)
```

There are many additional arguments that can be passed to `pivot_wider()` and `pivot_longer()`, which are explained in the function help files, e.g. `?pivot_wider`. We've just covered some of the more basic ones to show how we can easily go between between wide and long format data. Now you can have a go yourself in the exercises below!


---

### Exercise 1

You have received summary tables showing quarterly totals of adult reoffenders in England and Wales, beginning in 2010 quarter two. The data are split by number of previous offences of the offender prior to their current offence.

Read in the data:

```{r, purl=purl_example_code}
reoffending_real <- Rs3tools::s3_path_to_full_df(
    s3_path = "s3://alpha-r-training/intro-r-extension/adult_reoff_by_prev_off_number_2.csv")
```

This data table is in wide format, but if you were to plot the data with `ggplot2`, you would need to put it in long format.

 a) Put the data in long format
 b) Remove relevant prefixes
 c) Pass the labels 'quarter' and 'count' to the appropriate arguments to name the columns in your long format table.

---

Note, these are real data on reoffending, publicly available, derived from the table [here](https://www.gov.uk/government/statistics/proven-reoffending-statistics-april-to-june-2021).

Here's a preview of the data table:

```{r, purl=purl_example_code}
head(reoffending_real)
```

---

### Exercise 2

Your project manager likes the resulting plot, but wants to be able to see trends in counts over time more easily. Going from the long format table:

 a) Put the data back into wide format
 b) Add a prefix of your choice to the new columns you create
 c) Round the values to the nearest thousand

---

```{r, include=show_solution, purl=purl_solutions}
# Reshaping - solution to exercise 1
reoffending_real_long <- reoffending_real %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('total'),
    values_to = 'count',
    names_to = 'quarter',
    names_prefix = 'total_'
  )

head(reoffending_real_long)
```

---

```{r, include=show_solution, purl=purl_solutions, warning = FALSE, message = FALSE}
# Reshaping - solution to exercise 2
reoffending_real_wide <- reoffending_real_long %>%
  tidyr::pivot_wider(
    names_from = 'quarter',
    values_from = 'count',
    names_prefix = 'count_',
    values_fn = ~ round(.x, -3)
  )

head(reoffending_real_wide)
```
