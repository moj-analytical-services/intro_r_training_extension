# Reshaping data


The tidyr package can help us to reshape dataframes - this can be really helpful when we need to transform between tables that are easier to read and tables that are easier to analyse. For example, we might need to structure a dataset so that it can be manipulated more easily at a later stage of the analysis.

These situations may arise when there is more than one category associated with each value in a dataset. The dataset can be **lengthened** or **widened** (increasing the number of rows or columns, respectively), and this process is commonly referred to as **pivoting**.


## Transforming from wide to long format

Let's take a look at the `billboard` dataset supplied with tidyr (it should be available when you load the package), which contains the rank of songs in the year 2000. The dataset has 79 columns (one for each week, starting from Oct 1999, along with the artist, track name, and release date) and 317 rows.

```{r, purl=purl_example_code}
# Preview the data
billboard %>% head(10)
```

We can use the `pivot_longer()` function to help restructure this dataframe by decreasing the number of columns while increasing the number of rows. For example, we can map the first four week columns into a pair of new variables, called `month1` and `rank`.


```{r, purl=purl_example_code}
# Start by mapping a single month 
billboard_longer <- billboard %>%
  tidyr::pivot_longer(cols = c(wk1,wk2, wk3, wk4), names_to = "week_of_month1", values_to = "rank") %>% head()

# Display what we've done
billboard_longer %>% dplyr::select(artist, track, date.entered, week_of_month1, rank)
```

In the `pivot_longer()` function, we've specified variables/columns to be **gathered** into a new pair of columns using the `cols()` argument, then the `names_to` argument specifies the name of a new column to contain the names of the gathered columns, and `values_to` specifies the name of a new column to contain the corresponding values.  

### Working with similarly named columns

There might be a situation where we have a lot of columns to gather, in which case it would be time consuming to type them all out individually. What happens if we want all of the week columns to be restructured?

In this case, we can use the `starts_with()` function to select all columns with a name that begins with 'wk':

```{r, purl=purl_example_code}
# Mapping all week columns to new variables called "weeks" and "rank"
billboard %>% tidyr::pivot_longer(cols = starts_with("wk"), names_to = "week", values_to = "rank") %>% head()
```


This has allowed us to convert a dataframe with 79 columns into one with only 5, while retaining all of the same information, which can be helpful for making further analysis easier.


### Working with similar columns 

In some circumstances pivoting can also be used to construct a more robust for ease of use in later stages of the analysis. In these cases the dataset contains variables that are similar in their structure with the aim being to gather them in to one, cleaner, format. Consider the `asncombe` dataset that comes with basic R as shown below:

```{r, purl=purl_example_code}
anscombe
```

As it is apparent, the basis for each variable is the same (x1,x2, y1,y2 etc) and so it would make sense to simply create pair `x` and `y` and depict their corresponding identifier `1,2,3,4` in a separate variable. 

In such cases, `pivot_longer` offers an elegant solution to the problem by automatically selecting the common patterns and using them as the new variables.

```{r, purl=purl_example_code}
# using ".value" and "everything()" to select common variables
anscombe %>% tidyr::pivot_longer(everything(),
   names_to = c(".value", "set"),
   names_pattern = "(.)(.)" )
```


In the example above, the `.value` identifier enables selection of the common elements between `x1,x2,etc` and `y1,y2,etc` and then uses the findings as separate variables. 

The `everything()` argument, as the name would suggest, picks the entire variable set in the dataset.

Notice also the use of the `names_pattern = "(.)(.)"` option. This is a special kind of regex use where the values within the brackets are used to detect the kind of pattern to be used. 

The `names_pattern` or `name_sep()` options make explicit use of the `extract()` and  `separete()` tools respectively (discussed in more detail in the  next sections) utilizing regular expressions to detect the variable to pivot. In the former expression, the regex contained in the matching groups depicted within the brackets in the above expression, is what distinguishes one part of the variable from the other.  


## Transforming from long to wide format

The `pivot_wider()` function is the inverse of `pivot_longer()`, and transforms a dataframe to a **wider** format, with more columns and fewer rows. This wider format is often preferrable for displaying data, as it easier for a person to look at and interpret.

Consider the `fish_encounters` dataset, which contains a record of fish that are detected by various monitoring stations.

```{r, purl=purl_example_code}
fish_encounters %>% head(10)
```

We can use the `pivot_wider()` function to restructure this dataframe into a wide format: 

```{r, purl=purl_example_code}
fish_encounters %>% tidyr::pivot_wider(names_from = station, values_from = seen)
```

The `names_from` argument is used to specify the column containing categories we want to split across multiple columns, and the `values_from` argument contains the corresponding values for each category. 

In this dataframe there are some combinations of `fish` and `station` that don't exist in the original data, therefore the `values_fill` argument can be used to specify a value for these. In this case we've chosen to fill the NA values with zero:

```{r, purl=purl_example_code}
fish_encounters %>% tidyr::pivot_wider(names_from = station, values_from = seen, values_fill = list(seen = 0))
```


### Aggregating with `pivot_wider`

Consider the `warpbreaks` dataset, which describes the results of a designed experiment with nine replicates for every combination of wool (A and B) and tension (L, M, H). 

```{r, purl=purl_example_code}
warpbreaks %>% dplyr::select(wool, tension, breaks)
```

Note the warning that appears when trying to widen this dataset. This is because some combinations of `wool` and `tension` are repeated several times. 

```{r, purl=purl_example_code}
warpbreaks %>% tidyr::pivot_wider(names_from = wool, values_from = breaks)
```

To deal with this issue, we can use the optional `values_fn` argument in the `pivot _wider()` function, which allows us to specify a function to use to aggregate the multiple values. For example, we can specify to calculate the mean number of breaks for each combination of `wool` and `tension` like so:

```{r, purl=purl_example_code}
warpbreaks %>%
  tidyr::pivot_wider(
    names_from = wool,
    values_from = breaks,
    values_fn = list(breaks = mean)
  )
```


## Separating and extracting column contents

An Important aspect of every data shaping mechanism is to be able to pick multiple columns or data entries within a variable  with a certain precision and without having to manually type them each time. 

The functions `separate()` and `extract()` were created for this purpose where regex is used to describe the pattern to pick and reshape.

Consider `table3` for example that comes with the `tidyr` package. One look at the table illustrates the problem that we are facing where the variable `rate` could be split into two different ones if somehow we could detect and pull out the values on either side of the separator.  


```{r, purl=purl_example_code}
table3
```

### Separate

The `separate()` function is build to help in cases where values in a column could be split based on a separator in place. On the above example in `table3` the following code splits the `rate` variable into `cases` and `population` accordingly 


```{r, purl=purl_example_code}
# separate() automatically detects the separator
table3 %>% tidyr::separate(rate, into = c("cases", "population"))
```

By default, the function will automatically detect any non-alphanumeric character and use that as a separator but its not limited to that. One can specify the separator manually using the `sep` option.

```{r, purl=purl_example_code}
# separate() manually  detects the separator
table3 %>% tidyr::separate(rate, into = c("cases", "population"), sep = "/")
```

At its heart, `separate()` uses regular expressions to detect and pull the corresponding characters. As a result the new columns are now of `char` type, something that can be changed by altering the state of the `convert` flag as shown below:


```{r, purl=purl_example_code}
# separate() manually detects the separator and convers the columns into the appropriate data type 
table3 %>% tidyr::separate(rate, into = c("cases", "population"), sep = "/", convert = TRUE)
```

### Extract

The `extract()` function lets you go a step further and allows you to define your own regex to be used for pattern patching. Using the same example as above, lets see how to split the `year` variable to `century` and `years`.

```{r, purl=purl_example_code}
table3 %>% tidyr::extract( col = year, into = c("century","years"), regex = "([0-9]{2})([0-9]{2})")
```

The `regex` option shown above uses the same syntax as described earlier in the chapter, in fact, it is possible to split the target variable into several others by expanding the bracket list as shown in the following block of code. The year variable is now split into three variables to depict the `century`, `decade` and `year`.


```{r, purl=purl_example_code}
table3 %>% tidyr::extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")
```

In addition, internally the pivot functions make explicit use of  `seaprate()` and `extract()` whenever a split or a regular expression is need to capture patterns present in name or within the content of a variable in the dataset. 


### Unite

Of course, extracting and creating new variables would not be complete without a function to revert back to the original target variable. In this case, the `unite()` function provides the means to do exactly that as shown in the example below.


```{r, purl=purl_example_code}
# the reshaped dataset
tab3 = table3 %>% tidyr::extract( col = year, into = c("century","decade","year" ), regex = "([0-9]{2})([0-9])([0-9])")

# going back to the original dataset - with separator
tab3 %>% tidyr::unite(new ,century, decade, year)
```

By default, the `_` separator is used after each component of the composite variable but as always, there are option in place to customize this behavior. In the following block of code the separator is removed giving the original variable before any alteration takes place.


```{r, purl=purl_example_code}
# going back to the original dataset - with no separators
tab3 %>% tidyr::unite(new ,century, decade, year, sep = "")
```


## Exercises 

### Pivoting

#### Exercise 1 

Why does the following code fail?

```{r, purl=purl_example_code}
#the table to use
table4a
```

```{r, purl=purl_example_code, eval=F}
table4a %>% tidyr::pivot_longer(1999, 2000, names_to = "year", values_to = "value")
```


#### Exercise 2

Consider the following dataset and apply `pivot_wider()` to **spread** the values in `name`, do you agree with the results after pivoting? 

Hint. Could a new column solve the problem, what other solution could we apply?

```{r, purl=purl_example_code}
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)
```


#### Exercise 3

Consider the followign simple tibble, what kind of pivoting would you use, `pivot_longer()` or `pivot_wider()` ?

```{r, purl=purl_example_code}
rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)
```



### Separating and Extracting

#### Exercise 1

What to the additional arguments `extra` and `fill` do in `separate()`?  

Experiment with the various option in using the following datasets.


```{r, purl=purl_example_code}

tibble(x = c("a,b,c", "d,e,f,g", "h,i,j")) %>% 
  tidyr::separate(x, c("one", "two", "three"))

tibble(x = c("a,b,c", "d,e", "f,g,i")) %>% 
  tidyr::separate(x, c("one", "two", "three"))

```


#### Exercise 2


Both  `unite()` and `separate()` have a remove option. What does in to and how can it be utilized

#### Exercise 3

Compare `separate()` and `extract()`, why are there so many option to separate but only one `unite()`?

## Solutions

### Pivoting

#### Exercise 1

```{r, include=show_solution, purl=purl_solutions}
# Solution
table4a %>% tidyr::pivot_longer(cols = !country, names_to = "year",values_to = "value")
```



#### Exercise 2


```{r, include=show_solution, purl=purl_solutions}
# Solution

# Without changing anything on the dataset
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)
people %>% tidyr::pivot_wider(names_from = name, values_from = value)

# Solution 1 - adding a new column
people = tribble(~name, ~key, ~value, ~dkey,
                 "Phil Woods", "age",45,1,
                 "Phil Woods", "height",185,1,
                 "Phil Woods", "age",50,0,
                 "Jess Cordero", "age",45,1,
                 "Jess Cordero", "height",156,1)

people %>% tidyr::pivot_wider(names_from = name, values_from = value)

# Solution 2  - uniqueness
people = tribble(~name, ~key, ~value,
                 "Phil Woods", "age",45,
                 "Phil Woods", "height",185,
                 # "Phil Woods", "age",50,
                 "Jess Cordero", "age",45,
                 "Jess Cordero", "height",156,)

people %>% tidyr::pivot_wider(names_from = name, values_from = value)
```



### Exercise 3

```{r, include=show_solution, purl=purl_solutions}
# Solution

rcj = tribble( ~judge, ~male, ~female,
                    "yes", NA, 10, 
                    "no", 20, 12)

#alternative table to try with no NAs
# rcj = tribble( ~judge, ~male, ~female,
#                     "yes", 4, 10, 
#                     "no", 20, 12)


#use of pivot_longer
rcj %>% tidyr::pivot_longer(cols = c(male, female), names_to = "gender", values_to = "count")


# use of  pivot_wider 
rcj %>% tidyr::pivot_wider(names_from = judge, values_from = c(male, female))



```




### Separating and Extracting

#### Exercise 1

Typing `?separate()` into the R console shows all the arguments and their meanings. Try experimenting with them to discover more about what they do.


#### Exercise 2

Solution: Typing `?separate()` in the command line shows all the  information needed here. The `remove` option is there to remove the input columns from the output. 


#### Exercise 3

Solution: one suggestion is that there is only one way to unite the multiple strings but a number of different ways to split them apart. 


