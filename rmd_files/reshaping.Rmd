
# Reshaping data


## Introduction

The exact same data can be represented in different formatsorientations, depending on the purpose.

A dataframe that is in long format is one in which each row represents a single observation, and variables are organized into separate columns. The number of columns is minimized, at the expense of having many rows.

A dataframe that is in wide format is one on which each row represents a single observation, and each variable has its own column. The number of rows is minimised, at the expense of many columns.

There are advantages and disadvantages of each depending on context, and it is useful to know how to switch between these. It is very easy with the `tidyverse` functions (package `tidyr`) `pivot_wider()` and `pivot_longer()`.


---


## Widening data

We read in a data table.


```{r, purl=purl_example_code ,eval=T}
# read in the fake annual offences data
annual_offences <- 
  Rs3tools::s3_path_to_full_df(
    s3_path = "s3://alpha-r-training/intro-r-extension/annual_offences_fake.csv", 
    colClasses = c("integer", "character", "integer")) %>%
  tibble::tibble()

head(annual_offences)

```

---

The data represent fake frequencies of offences from 2016 to 2020, represented by real offence codes. If an offence was prosecuted in a year, there is a corresponding line in this data table, with the offence code indicated by the `offence_code` column, the year indicated by the `year` column, and the `count` column representing the number of times the offence was prosecuted. If an offence was not prosecuted in a year, the corresponding combination of `year` and `offence` does not exist. The table has been sorted by year and offence code.

The long format may be a good way to store data like these for some purposes, but what if we want to put it into wide format, e.g. to make it easier for a human to read? We use the `tidyr` function `pivot_wider()`:


```{r, purl=purl_example_code ,eval=T}
# basic implementation of pivot_wider()
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count'
  )

head(wide_annual_offences)
```

What's happened? We passed `count` to the argument `values_from` and `year` to the argument `names_from`. This tells the function that we want to make new columns based on `year`, and populate it with the values from `count`.

Remember that the data are sorted first by year? If we imagine each year as a stack of data, what we're effectively doing here is taking the count data for each stack and putting them in their own column.

There are a couple of ways we could get more useful results from this function, though.

First, it's generally not a good idea to have column names, that begin with numbers. Fortunately, `pivot_wider()` has the useful argument `names_prefix` to remedy this.

```{r, purl=purl_example_code ,eval=T}
# adding a prefix to new columns
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_'
  )
head(wide_annual_offences)
```

When transforming count data like this we may have legitimate good reason to replace our NAs with 0s, which we can do with `values_fill()`:

```{r, purl=purl_example_code ,eval=T}

# filling in NAs with 0
wide_annual_offences <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_',
    values_fill = 0
  )
head(wide_annual_offences)
```

Once our table is in wide format, and clean, we can easily do transformations like this. Here we use `dplyr` functions to create a new column that adds up yearly totals across each column that has count data.

```{r, purl=purl_example_code ,eval=T}

#starting by mapping a single month 
wide_annual_offences_with_totals <- wide_annual_offences %>%
  dplyr::mutate(
    count_2016_2020 =
      rowSums(dplyr::across(dplyr::starts_with("count"))))
```


The final and most advanced thing we will do with `pivot_wider()` is to pass it an auxiliary function to transform the values that it places in its new columns.

Here we are passing an anonymous function which itself calls the `round()` function to round our counts. The `digits` argument tells `round()` to round one place before the decimal.

```{r, purl=purl_example_code, eval=T}
#mapping all weeks to one variable called "weeks" 
wide_annual_offences_rounded <- annual_offences %>%
  tidyr::pivot_wider(
    names_from = 'year',
    values_from = 'count',
    names_prefix = 'count_',
    values_fill = 0,
    values_fn = ~ round(.x, digits = -1)
  )
head(wide_annual_offences_rounded)
```

---

## Widening data

Let's consider our earlier widened table, with original counts, columns with prefixes and NAs replaced with 0s.

What if we want to go from our widened table back to our original one, here?


```{r, purl=purl_example_code, eval=T}
head(wide_annual_offences)
head(annual_offences)
```

We use the function `pivot_longer()` for this. You can pass column names to it like this:

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = c('count_2016', 'count_2017', 'count_2018', 'count_2019', 'count_2020')
  )
head(long_annual_offences)
```

Or, as our column names are conveniently named with a prefix, we can use `starts_with()` from `dplyr` again:

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count')
  )
```


Essentially, these data are the same as what we started with, but, not quite.

```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

There are several difference, which we can correct via arguments to `pivot_wider()` and some `dplyr` functions.

```{r, purl=purl_example_code, eval=T}
head(annual_offences)
head(long_annual_offences)
```

First, the default column name `value` has been assigned to our count, which we correct with the argument `values_to`, giving it the label we see in the original table.

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count'
  )
head(long_annual_offences)
```

```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

There's another default name that it's assigned too - it's used `name` when we want `year` to indicate the years. We correct this with an equivalent argument

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year'
  )
```


```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

We also want to remove those prefixes

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  )
```

```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

Still more to do! We have more rows in our new table, and that's because of those year/offence combinations were there are no incidences. Let's get `dplyr` involved, and filter these out

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  ) %>%
  dplyr::filter(count > 0)

nrow(long_annual_offences) == nrow(annual_offences)
```

```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

Finally, we use dplyr to:
- fix data types and reorder columns (with `transmute`)
- order rows

```{r, purl=purl_example_code, eval=T}
long_annual_offences <- wide_annual_offences %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('count'),
    values_to = 'count',
    names_to = 'year',
    names_prefix = 'count_'
  ) %>%
  dplyr::filter(count > 0) %>%
  dplyr::transmute(
    year = as.integer(year),
    offence_code,
    count
  ) %>%
  dplyr::arrange(year, offence_code)
```

What do they both look like now?

```{r, purl=purl_example_code, eval=T}
head(annual_offences)
head(long_annual_offences)
```
Success!

```{r, purl=purl_example_code, eval=T}
identical(long_annual_offences, annual_offences)
```

## Pivoting Exercises

### Exercise 1

You have received summary tables showing quarterly totals of adult reoffenders split by number of previous offences of the offender. 

Read in the data:

Note, these are real data on reoffending, publicly available, derived from the table [here](https://www.gov.uk/government/statistics/proven-reoffending-statistics-april-to-june-2021)

```{r, purl=purl_example_code, eval=T}
reoffending_real <- 
  Rs3tools::s3_path_to_full_df(
    s3_path = "s3://alpha-r-training/intro-r-extension/adult_reoff_by_prev_off_number_2.csv")
```

This data table is in wide format, but in order to plot the data you need to put it in long format.
- Put the data in long format
- Remove relevant prefixes
- Pass the labels 'quarter' and 'count' to the appropriate arguments to name the columns in your long format table.



### Exercise 2

Your project manager likes the resulting plot, but wants to be able to see trends in counts over time more easily. Going from the long format table:
- Put the data back into wide format
- Add a prefix of your choice to the new columns you create
- Round the values to the nearest thousand


## Solutions


### Exercise 1

```{r, include=show_solution, purl=purl_solutions}
reoffending_real_long <- reoffending_real %>%
  tidyr::pivot_longer(
    cols = dplyr::starts_with('total'),
    values_to = 'count',
    names_to = 'quarter',
    names_prefix = 'total_'
  )
```

---

### Exercise 2

```{r, include=show_solution, purl=purl_solutions, warning = FALSE, message = FALSE}
reoffending_real_wide <- reoffending_real_long %>%
  tidyr::pivot_wider(
    names_from = 'quarter',
    values_from = 'count',
    names_prefix = 'count_',
    values_fn = ~ round(.x, -3)
  )
```