# String manipulation


```{r, echo=F, message=F, results=F}

# loading packages
# 
library(tidyverse)
library(stringr)

```

### Introduction

In this part we will introduce strings and how to manipulate them to suit the needs of a particular project. The packages needed (listed above) are mostly the `stringr` and  `tidyverse` package where the former contains a great number of functions to manipulate and work with strings and the latter is the base for most of the things we do in R. 

Base R has a a number of functions to manipulate and work with strings but they can be inconsistent at times,  the above package was created in an effort to standardize character vector manipulation and make it easier to follow and replicate.  

It should also be mentioned that the majority of the content that follows is containd in the book `R for Data Science` by `Hadley Wickam` and `Garrett Grolemund` that can be found in this [link](https://r4ds.had.co.nz/index.html).

### String Basics

There are two ways with which you can create a string in R, at the very basic level, by either using single of double quotes. There is no difference in the behavior but it is recommended to stick with `"` as it is more widely understood that this is a string and others will be able to follow your code easier. 

To note here that one of the advantages of having two ways to define a string is that you can combine them when quotes within a string if needed as showcased in the example below. 


```{r, results=FALSE}
string1 = "a string using double quotes"

is.character(string1)

string2 = 'another string using single quotes'

is.character(string2)

# a string containing quotes
string3 = "this is a 'string' within a string"

# notice how the output changes when implementing the following code
string4 = 'this is a "string" within a string'


```


Notice the difference in `string4`. This happens because the compiler cannot place two double quotes within the same string and so we need to `escape` it. To achieve that a `\` is used before the corresponding character. This can be used not only for `"` but for any other reserved character as well. 

If you need to `escape` a backslash then use a double backslash as in `\\` and to see what the output would look like when used in text you can use the `writeLines()` function to simulate that effect. 


```{r, results=FALSE}
string5 = "escaping a reserved character like \" quotes "

# to see how the result would apear in text
writeLines(string5)

string6 = "escaping a backslash \\ "

# to see how the result would apear in text
writeLines(string6)

```



Furthermore, additional control in the form of newlines or tabs is provided by using `\n` and `\t` for example along with a plethora of available special characters that can be found by typing `?"'"` or `?'"'` in you command line. 

Introducing non-English characters in your text strings is also possible using special characters of the form `\u00b5` for example for the Greek letter mu. 

```{r, results=FALSE}

# outputting non-English characters
string7 = "\u00b5" 


```


Adding strings into a character vector is very common and is usually done with the use of the `c()` function. 

```{r, results=FALSE}

s8 = c("a", "vector", "of", "strings")


```



### String Length

At times it is necessary to determine the length of a character string. A useful function to use in these cases is the `str_length()` function which helps with that.

```{r, results=FALSE}

# finding out how many characters in a char vector
str_length(c(s8, NA))


```

Notice that an `NA` character is translated as is and we will see other options on how to deal with this in the sections to follow. 


### Combining Strings

We already seen one way to combine strings in the previous section but with the `stringer` package we have an additional, more powerful tool at our disposal. 

Using `str_c()` can be beneficial in many cases since it allows for additional flexibility in the form of parameters for separators to be used or the option to collapse individual entries into one composite character string. 

```{r, results=FALSE}
# using custom separator
str_c("an", "str_c vector", "with", "space", "character", "separating each entry", sep = " ")

# the colapse option
str_c("an", "str_c vector", "with", "space", "character", "separating each entry", collapse = T)

```

What is more important however is that `str_c` is vectorised and in this way can help in cases where an action has to be applied to each element of an input vector instead of individual character strings.

In addition, it can also work to recycle shorter vectors to mach the longer ones as in the following example. 


```{r, results=FALSE}

# vectorized form - translating a shorter vectror to match the longer one
str_c("a", c("b", "c", "d"), "c", sep = " " )

# simpler vectorizing 
str_c("a", c("b", "c", "d"))

# c() comparison
c("a", c("b", "c", "d"))

```

### Subsisting strings

Extracting parts of a string can be done using the `str_sub` function and by specifying the `start` and `end` limits of the string to retain.

It is also important to note that the function will not fail if the end point is outside of the index limit of the string.


```{r, results=FALSE}
x <- c("OneValue", "SecondValue", "ThirdValue")
str_sub(x, 1, 3)

# negative numbers count backwards from end
str_sub(x, -4, -1)


# The function will not fail in teh example below
str_sub("a", 1,5)



```

An additional use of the of the `str_sub` function is to assign values to a given range on the target string  

```{r, results=FALSE}
str_sub(x, 1, 1) <- str_to_lower(str_sub(x, 1, 1))
x

```


### Customizing text for different language locales

In some cases the string manipulation functions have a `locale` argument where adjustments for certain languages can be made. Notice
for example how the sort order changes if the locale changes from English to Lithuanian in the example below.


```{r, results=FALSE}
#initial string
x = c("y", "i", "k")

#sort function in English
str_sort(x)

#sort function in Lithuanian
str_sort(x,locale = "lt")



```

### Exercises

+ In code that doesn’t use stringr, you’ll often see paste() and paste0(). What’s the difference between the two functions? What stringr function  are they equivalent to? How do the functions differ in their handling of NA?

+ In your own words, describe the difference between the sep and collapse arguments to str_c().

+ Use str_length() and str_sub() to extract the middle character from a string. What will you do if the string has an even number of characters?

+ What does str_wrap() do? When might you want to use it?

+ What does str_trim() do? What’s the opposite of str_trim()?

+ Write a function that turns (e.g.) a vector c("a", "b", "c") into the string a, b, and c. Think carefully about what it should do if given a vector of length 0, 1, or 2.


NOTE: The content in this section as well as a more in depth analysis on each of the previous sections can be found in this book [R For Data Science](https://r4ds.had.co.nz/strings.html#exercises-32)  


## Regular Expressions

Matching patterns with regular expressions is usually covered in a very large topic and one that  arguably should be covered on its own course, however here we will consider it as part of the general string manipulation section and will include a flavor of what can be achieved.  


### Normal Pattern Matching 

Simple pattern matching can be achieved by using the `str_view` function and specifying the `string` and `pattern` arguments as shown below:



```{r, results=F}

x <- c("apple", "banana", "pear")
str_view(x, "an")

```


The complexity of the match can be adjusted and wildcards can be used as well in teh form of `.` as in 

```{r, results=F}
str_view(x, ".a.")


```


An important thing to remember here is that you are looking for given pattern in a string or a vector of strings. Specifying the pattern to look for can be sometimes tricky and therefore is recommended to take a look at the accompanied information sheet for the `stringr` package located [here](https://evoldyn.gitlab.io/evomics-2018/ref-sheets/R_strings.pdf). 

The most common functions for regular expressions as well as ways to strucure your pattern can be found in the above link.

### Escaping characters

We saw prevously that the wildcard is representd by `.`, what happens if your pattern needs to include the dot `.`?

For cases such as these there is a need to "escape" a charcter using the backlash `\`. So for example the dot (`.`) as stated previously would be normally used as `\.` in a regular expression. However, a problem arises since strings are used to represent regular expressions, they also use the backlash to represent an escaped character. The solution is to use the double backlash as in `\\.` to signify that we want to "escape" the dot (`.`) in a regular expression pattern.


```{r, results=F}

# To create the regular expression, we need \\
dot <- "\\."

# But the expression itself only contains one:
writeLines(dot)


# And this tells R to look for an explicit .
str_view(c("abc", "a.c", "bef"), "a\\.c")

```


If there is a need to match the `\` character itself then you will need to use the double version `\\` for regular expressions and since this is a string you will need to add one more `\` followed by the actual character. So four backlash characters will need to be used!


```{r}
#to see this in a string
x <- "a\\b"
writeLines(x)

# to view the result in a RegEx
str_view(x, "\\\\")
```

thourght this section the pattern for a RegEx will be presented as `\.` wheras the actual string as `\\.`. 



#### Exerceses


1. Explain why each of these strings don’t match a \: "\", "\\", "\\\".

2. How would you match the sequence "'\?

3. What patterns will the regular expression \..\..\.. match? How would you represent it as a string?



### Anchors


It is sometimes usefull to match a pattern starting from the begining or the end of a string. In these cases an anchor is used to notify the engine that we are using a point of origin. 

More specifically, the start of the string is denoted by `^` and the end by `$`

```{r, results=F}

x <- c("apple", "banana", "pear")
str_view(x, "^a")

str_view(x, "a$")


```


You can also use both in one pattern and this is usefull when the entire string is to be mathed 

```{r}
# this will output all possible matches
x <- c("apple pie", "apple", "apple cake")
str_view(x, "apple")

# notice the difference in the result here
str_view(x, "^apple$")


```



#### Exercises

1. How would you match the literal string "$^$"?

2. Given the corpus of common words in stringr::words, create regular expressions that find all words that:

      +Start with “y”.
      +End with “x”
      +Are exactly three letters long. (Don’t cheat by using str_length()!)
      +Have seven letters or more.
3. Since this list is long, you might want to use the match argument to str_view() to show only the matching or non-matching words.

###Charcter Classes

#### Exercises

### Repetition

#### Exercises


### Additional Functions













