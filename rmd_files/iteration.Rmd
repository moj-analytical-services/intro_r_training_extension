
# Iteration and Loops

```{r,echo=F, message=F, results=F}
# loading packages
# 
library(tidyverse)
library(stringr)
```


## Introduction


As part of any good coding practice is to reduce the number of repetitive tasks as much as possible. To help with this concept any programming language comes with a set of **control structures** to help reduce clutter in the code and make it more readable and easier to understand.

A general rule in programming is to never copy an paste code more than twice; if you find that you are using repeated statements over and over again, this is a good sign that either a loop or a function or both are needed to make the code more compact and efficient. 

Loops form part of the core of any programming platform and R is no different here. In the section to follow we will cover the for loos and its variants and explain a few things about `purrr` and how we can iterate through lists using a variety of *maps*. 

A note here similar to what was mentioned in previous chapters, the content in this section can also be found in Hadley Wickham's and Garrett Grolemund's book [R For Data Science](https://r4ds.had.co.nz)


## For Loops

The basics of how a for loop works can be understood best by using an example. Consider the following tibble:



```{r}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
```

the task now is to calculate, for example, the mean or the median:

```{r}
median(df$a)
#> [1] -0.2457625
median(df$b)
#> [1] -0.2873072
median(df$c)
#> [1] -0.05669771
median(df$d)
#> [1] 0.1442633
```


one way of doing this is by copying and pasting the same code over and over again; inefficient, but possible at this stage. A much better way is to construct a for loop and iterate through the code that is repeated as above.

```{r}
output <- vector("double", ncol(df))  # 1. output
for (i in seq_along(df)) {            # 2. sequence
  output[[i]] <- median(df[[i]])      # 3. body
}
output
#> [1] -0.24576245 -0.28730721 -0.05669771  0.14426335
```

In the example above the For loop has three primary components,  the *output*, the *sequence* and the *body*. The output is usually a list or a vector where the result of the loop is to be stored. the sequence is  a vector or a list containing the collection of items to cycle through while running. The iterator `i` is used as a place holder variable, changing each time the loop runs to the corresponding value ion the given sequence. As the loop runs `i` runs through all the values in the `sequence` in the order they appear.  

The body of the loop contains the code to run at each iteration. The iterator `i` will be take the value of each element in the sequence on each run. 


### Exercises

1. Write for loops to:

  1. Compute the mean of every column in mtcars.
  2. Determine the type of each column in nycflights13::flights.
  3. Compute the number of unique values in each column of iris.
  4. Generate 10 random normals from distributions with means of -10, 0, 10, and 100.

Think about the output, sequence, and body before you start writing the loop.


## For loop variants

Now that you know the basics of the for loop, it is time to see a few of its variants and how they can be used in very common programming tasks. 

There are 4 variants to consider here:

1. Modifying an existing object on the spot.
2. Looping over a list of names or values.
3. Handling outputs of unknown length.
4. Handling sequences of unknown length.

and we will cover each in the sections below. 


### Modifying an existing object

In many cases there will be a need to modify a given object based on the current data analysis task. In the example below the task is to scale the data frame for further processing. On way to achieve this is by manually change each column in the data; this could be fine for small dataframes but for larger ones this will very quickly become a problem. 


```{r, error = TRUE}
df <- tibble(
  a = rnorm(10),
  b = rnorm(10),
  c = rnorm(10),
  d = rnorm(10)
)
rescale01 <- function(x) {
  rng <- range(x, na.rm = TRUE)
  (x - rng[1]) / (rng[2] - rng[1])
}

df$a <- rescale01(df$a)
df$b <- rescale01(df$b)
df$c <- rescale01(df$c)
df$d <- rescale01(df$d)
```


A for loop in this case would be recommended as you will notice that the same one line of code is repeated throughout. The code below illustrated this concept. 

More specifically the components of the for loop are:

+ The**output** -  in this case we don't output to a different object we just update the input. The output is the same as the input
+ The **sequence** - This will be the number of columns in `df` we want to run the code to. As previously the `seq_along` function will help us with this as it will count the number of columns and turn this into a sequence we can use in the for loop

+ The body of the loop is just the re scale one line of code running the defined `rescale01` function. It can be anything that will take the column as an argument to work with. Further restrictions would normally apply but we will not cover this here

The code below simplifies what we want to do and as you can see, overall, we now have a much better structured and easier to read two lines of code!



```{r}
for (i in seq_along(df)) {
  df[[i]] <- rescale01(df[[i]])
}
```

### Looping patterns

There are a couple of ways we can use to access the sequence part of the **for** loop depending on the coding style and the needs of the project. For example, in the code shown below, one could choose to loop over the list of indices of a vector using `for(i in se_along(x)` or alternatively iterate through the contents of the `results` vector using `for(i in vowel)`. Both formulations are valid with the first one allowing for more flexibility when it comes to accessing the resources of the vector.

```{r, error = TRUE}
x = letters # vector of letters
vowel <- c('a', 'e', 'i', 'o', 'u')

results <- rnorm(length(x)) #create a random vector
names(results) <- x # name the elements of the vector 

## loop thourgh indices of a vector
## 
x1 = 0
for(i in seq_along(x)){
  x1[i] = paste(x[i],"23")
}

## loop through contents of a vector
## 
for(i in vowel){
  print(results[i])
  }

```


### Handling outputs of unknown length

There are cases where the output from a loop is not known beforehand. In these cases, certain precautions need to be taken as it may result in clogging up the memory with vectors going out of control expanding indefinitely. 

```{r}
a = 0 # initialize number

# run a sequence of random length vectros to be appended
for(i in seq_len(10)){
  n = sample(20,1)
  a = c(a,rnorm(n))
}
```


A better way to achieving the above result would be to create a list and capture the results within each cell at each corresponding iteration. The result would be a list with a  predictable index length. 

```{r}
a = list() # initilise a list

# populate the contents of each cell of a list with a random size vector created in each iteration 
for(i in seq_len(10)){
  n = sample(20,1)
  a[[i]] = rnorm(n)
}
```




### Handling sequences of unknown length

In general, unknown sequence length translates to cases where we want to check for certain condition in order to stop the execution of a block of code. In these cases the use of the `while` loop is preferable as in the example below.

```{r, eval=FALSE, echo=TRUE, error = TRUE}
## while loop definition

while (condition) {
  # body
}
```

Notice that the `while` loop execution differs that the `for` loop in that the body of code is executed first before the condition is checked and this is by design. One needs to first check the contents before accessing the validity of the condition to terminate the loop.   

```{r, error = TRUE}
# The loop will first execute the body of code and then check if the condition is satisfied. If this is the case the loop will stop its iteration.
numbers = 0

while(mean(numbers) < 0.5){
  numbers = rnorm(20)
  print(mean(numbers))
}
```


##Exercises

1. Imagine you have a directory full of files that you want to read in. You have the file names in the vector `files`, and now want to read each one. Write the for loop that will simulate reading them into a single data frame.

```{r, error = TRUE}
# the following code will create a random colelction of file names
files = paste0(str_extract(sentences[1:5], "^[:alpha:]+"), sample(c(".csv",".xlsx")))

```


2. What happens if you use `for (nm in names(x))` and x has no names? What if only some of the elements are named? What if the names are not unique?

```{r, error = TRUE}
# try using the folling list of files 
files2 = paste0(str_extract(sentences[1:10], "^[:alpha:]+"), ".xlsx") 
files2[5] = NA
```

