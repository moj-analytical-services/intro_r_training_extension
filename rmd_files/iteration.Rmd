
# Iteration


## Introduction

Best practice for programming involves reducing code repetition as much as possible. This helps prevent code getting overly long and complicated, and makes it more readable and easier to understand.

A general rule of thumb in programming is never to copy and paste a piece of code more than once; if you find that you are repeating similar pieces of code over and over again, this is a sign that either a loop or a [function](https://github.com/moj-analytical-services/writing_functions_in_r) (or both) are required. 

Loops form a core part of any programming language and R is no different. In the following section we cover different uses of **for loops** and take a look at the `purrr` package from Tidyverse to help iterate through lists. 

The content in this section can also be found in Hadley Wickham's and Garrett Grolemund's book [R For Data Science](https://r4ds.had.co.nz)


## For Loops

Let's start with a very basic example to illustrate what a for loop does. Say we wanted to print the numbers 1 to 5; without a for loop we'd need to write something like this:

```{r, collapse = TRUE, purl=purl_example_code}
print(1)
print(2)
print(3)
print(4)
print(5)
```

Clearly there is some code repetition here, so we can achieve the same result using a for loop written like so:

```{r, purl=purl_example_code}
for (i in 1:5) {
  print(i)
}
```

Inside the brackets of the for loop you define a variable (in this case called `i`), along with what you want to iterate over (referred to as the iterable - in this case the numbers 1 to 5, denoted `1:5` in R). For each iteration, the variable `i` will take on a value equal to the next element of the iterable. The loop body goes inside the curly brackets, which is where you define what you want to happen for each iteration (in this case printing the value of `i`).

In the previous example we iterated over a sequence of numbers, but in R you can iterate over anything you like. Here's a similar example, but iterating over a vector of strings instead of a sequence of numbers:

```{r, purl=purl_example_code}
strings <- c("spam", "egg", "chips", "beans")

for (string in strings) {
  print(string)
}
```

Other things that could be iterated over include file names or columns of a dataframe.

If you wanted to get an index number for each element of the iterable, you can use the `seq_along()` function. For example:

```{r, purl=purl_example_code}
strings <- c("spam", "egg", "chips", "beans")

for (i in seq_along(strings)) {
  print(paste(i, strings[i]))
}
```

You can also use for loops to populate or modify a vector or dataframe. The following example shows how we can add the first ten numbers of the Fibonacci sequence to a vector:

```{r, purl=purl_example_code}
n <- 10 # Specify what length we want our output vector to be
fibo <- vector("numeric", n) # Define an empty numeric vector of length n that we'll populate using the loop

# Set up the first couple of numbers to get the sequence started
fibo[1] <- 0 
fibo[2] <- 1

# Add the rest of the sequence
for (i in 3:n) {
  fibo[i] <- fibo[i-1] + fibo[i-2]
}

print(fibo)
```

When writing a for loop you must define something to iterate over a fixed number of times in advance. It is also possible to iterate indefinitely using a different kind of loop - this is covered in the section on while loops, below.


### Exercise

1. Write for loops to:

  1. Compute the mean of every column in mtcars.
  2. Determine the type of each column in nycflights13::flights.
  3. Compute the number of unique values in each column of iris.
  4. Generate 10 random normals from distributions with means of -10, 0, 10, and 100.

Think about the output, sequence, and body before you start writing the loop.





### Handling outputs of unknown length

There are cases where the size of an output from a loop is not known beforehand. For example, this might be because different iterations result in outputs of different lengths. The most memory efficient way to handle this is to add the output from each iteration to a list structure, where the length of the list is the same as the length of the iterable, and then to combine the list elements together afterwards. 

Let's say we want to join together dataframes of different lengths. There is a shared folder prepared in the alpha-r-training s3 bucket, which contains some data for us to read in and combine together. We might not even know in advance how many datasets there are to join together. Fortunately we can use the s3tools package to get a list of files to read in:

```{r, message=F, warning=F, purl=purl_example_code}
# Get a vector of csv files we can iterate over
files <- s3tools::list_files_in_buckets("alpha-r-training", prefix="intro-r-extension", path_only=T)
files <- files[grepl(".csv", files)]

files
```

Now we can use a for loop to read in each file as a dataframe, and add each dataframe to a list. After the for loop, the `bind_rows()` function from dplyr can be used to combine the data into a single dataframe.

```{r, message=F, warning=F, purl=purl_example_code}
# First define an empty list with the same length as the number of datasets to be read in
fruit_list <- vector("list", length(files))

# Loop over each file, and add the data to a list
for (i in seq_along(files)) {
  fruit_list[[i]] <- s3tools::s3_path_to_full_df(files[i])
}

# Combine the list of dataframes into a single dataframe
fruit <- dplyr::bind_rows(fruit_list)
fruit
```


## While loops

There may be cases where we want to keep looping over a piece of code until a certain condition is met, rather than having to specify in advance how many times a loop should run. In these cases a `while` loop can be used.

The syntax for a while loop is similar to that of a for loop, but in the brackets a condition is specified instead of an iterable. Prior to writing the while loop you'll also need to specify a start value for the variable used in the loop, and there should be something in the body of the loop to change the variable during each iteration - otherwise the condition can never be met! For example, we can use a while loop to achieve a similar result to the first for loop example above:

```{r, purl=purl_example_code}
# First specify an initial value for the variable used in the while loop
i <- 1

# Now define a while loop
while (i <= 5) { # The loop will continue until the condition i<=5 is met
  print(i)
  i = i + 1 # Set the value of the variable for the next loop iteration
}
```

Generally a while loop should only be used in circumstances where it isn't possible to achieve the desired result using a for loop. The reason for this is that it's quite easy to accidentally set up an infinite loop, where a bug in the code means that the condition is never met for a while loop to end.


### Exercises

1. Imagine you have a directory full of files that you want to read in. You have the file names in the vector `files`, and now want to read each one. Write the for loop that will simulate reading them into a single data frame.

```{r}

# the following code will create a random colelction of file names

files = paste0(str_extract(sentences[1:5], "^[:alpha:]+"), sample(c(".csv",".xlsx")))


```


2. What happens if you use `for (nm in names(x))` and x has no names? What if only some of the elements are named? What if the names are not unique?

```{r}
# try using the folling list of files 

files2 = paste0(str_extract(sentences[1:10], "^[:alpha:]+"), ".xlsx") 
files2[5] = NA
```

